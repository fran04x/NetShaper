

# CONTEXTO: 30 ARCHIVOS - CÓDIGO FUENTE COMPLETO
- NetShaper.Abstractions\IApplicationController.cs
- NetShaper.Abstractions\IEngine.cs
- NetShaper.Abstractions\IPacketCapture.cs
- NetShaper.Abstractions\IPacketLogger.cs
- NetShaper.Abstractions\PacketCaptureConstants.cs
- NetShaper.Abstractions\PacketLogEntry.cs
- NetShaper.Abstractions\RuleAttributes.cs
- NetShaper.Abstractions\WrapperResult.cs
- NetShaper.Benchmarks\Benchmarks.cs
- NetShaper.Benchmarks\LatencyJitterBenchmark.cs
- NetShaper.Composition\ServiceCollectionExtensions.cs
- NetShaper.Engine\ArrayPoolDiagnostics.cs
- NetShaper.Engine\Engine.cs
- NetShaper.Engine\EngineTelemetry.cs
- NetShaper.Infrastructure\ConsolePacketLogger.cs
- NetShaper.Infrastructure\RingBufferPacketLogger.cs
- NetShaper.Native\NativeMethods.cs
- NetShaper.Native\WinDivertAdapter.cs
- NetShaper.Native\WinDivertAddress.cs
- NetShaper.Native\WinDivertHandle.cs
- NetShaper.StressTest\PerformanceTests.cs
- NetShaper.StressTest\Program.cs
- NetShaper.StressTest\RealTests.cs
- NetShaper.StressTest\TestServiceFactory.cs
- NetShaper.UI\Bootstrap.cs
- NetShaper.UI\Program.cs
- NetShaper.UI\Controllers\ConsoleApplicationController.cs
- NetShaper.UI\Controllers\EngineController.cs
- NetShaper.UI\Views\ConsoleStatsView.cs
- NetShaper.UI\Views\IConsoleView.cs

# CONTENIDO
<codebase>
<file path="NetShaper.Abstractions\IApplicationController.cs">
<![CDATA[
// NetShaper.Abstractions/IApplicationController.cs
using System.Threading;
using System.Threading.Tasks;

namespace NetShaper.Abstractions
{
    public interface IApplicationController
    {
        Task<int> RunAsync(CancellationToken ct);
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\IEngine.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    public interface IEngine : System.IDisposable
    {
        bool IsRunning { get; }
        long PacketCount { get; }

        StartResult Start(string filter, System.Threading.CancellationToken ct = default);
        void Stop();
        EngineResult RunCaptureLoop();
    }

    public enum StartResult
    {
        Success = 0,
        InvalidFilter = 1,
        AlreadyRunning = 2,
        Disposed = 3,
        OpenFailed = 4
    }

    public enum EngineResult
    {
        Success = 0,
        Stopped = 1,
        InvalidState = 2,
        InvalidHandle = 3,
        InvalidParameter = 4,
        Aborted = 5,
        TooManyErrors = 6
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\IPacketCapture.cs">
<![CDATA[
// NetShaper.Abstractions/IPacketCapture.cs
using System;
using System.Runtime.InteropServices;

namespace NetShaper.Abstractions
{
    public interface IPacketCapture : IDisposable
    {
        CaptureResult Open(string filter);
        CaptureResult Receive(Span<byte> buffer, out uint length, ref PacketMetadata metadata);
        CaptureResult ReceiveBatch(Span<byte> buffer, Span<PacketMetadata> metadataArray, out uint batchLength, out int packetCount);
        CaptureResult Send(ReadOnlySpan<byte> buffer, ref PacketMetadata metadata);
        void Shutdown();
        void CalculateChecksums(Span<byte> buffer, uint length, ref PacketMetadata metadata);
    }

    public enum CaptureResult
    {
        Success = 0,
        InvalidFilter = 1,
        InvalidHandle = 2,
        InvalidParameter = 3,
        OperationAborted = 4,
        ElementNotFound = 5,
        BufferTooSmall = 6,
        Unknown = 99
    }

    /// <summary>
    /// Packet metadata structure.
    /// Layout matches WINDIVERT_ADDRESS (WinDivert 2.2) for zero-copy interop.
    /// StructLayout is acceptable here as it defines a performance-critical contract.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct PacketMetadata
    {
        public long Timestamp;
        public uint InterfaceIndex;
        public uint SubInterfaceIndex;
        public byte Direction;
        public byte Loopback;
        public byte Impostor;
        public byte IpChecksum;
        public byte TcpChecksum;
        public byte UdpChecksum;
        public ushort Reserved1;
        public uint Reserved2;
        
        // BATCH MODE SUPPORT: Length of packet in batch (populated by ReceiveBatch)
        public uint Length;
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\IPacketLogger.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    public interface IPacketLogger
    {
        void Log(in PacketLogEntry entry);
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\PacketCaptureConstants.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    /// <summary>
    /// Constantes compartidas para captura de paquetes y filtros WinDivert.
    /// </summary>
    public static class PacketCaptureConstants
    {
        /// <summary>
        /// Longitud máxima permitida para un filtro WinDivert.
        /// </summary>
        public const int MaxFilterLength = 1024;
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\PacketLogEntry.cs">
<![CDATA[
using System.Runtime.InteropServices;

namespace NetShaper.Abstractions
{
    [StructLayout(LayoutKind.Sequential)]
    public readonly struct PacketLogEntry
    {
        public readonly long Timestamp;
        public readonly LogLevel Level;
        public readonly LogCode Code;
        public readonly long Value;

        public PacketLogEntry(long timestamp, LogLevel level, LogCode code, long value)
        {
            Timestamp = timestamp;
            Level = level;
            Code = code;
            Value = value;
        }
    }

    public enum LogLevel : byte
    {
        Info = 0,
        Warning = 1,
        Error = 2
    }

    public enum LogCode : ushort
    {
        None = 0,
        EngineStarted = 1,
        EngineStopped = 2,
        PacketProcessed = 3,
        RecvFailed = 4,
        SendFailed = 5,
        InvalidPacket = 6,
        OperationAborted = 7,
        InvalidHandle = 8,
        InvalidParameter = 9
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\RuleAttributes.cs">
<![CDATA[
// NetShaper.Abstractions/RuleAttributes.cs
using System;

namespace NetShaper.Abstractions
{
    /// <summary>
    /// Marks methods that are allowed to use async/Task in Engine namespace.
    /// These are typically initialization or configuration methods that run outside the hot path.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class EngineSetupAttribute : Attribute { }

    /// <summary>
    /// Marks methods or classes that are application boundaries.
    /// These are allowed to catch generic Exception types.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]
    public sealed class BoundaryAttribute : Attribute { }

    /// <summary>
    /// Marks a class as the composition root for dependency injection.
    /// Each assembly should have at most one composition root.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class CompositionRootAttribute : Attribute { }

    /// <summary>
    /// Provides justification for rule violations that are acceptable.
    /// Used to document why a constructor exceeds normal dependency limits, etc.
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Constructor)]
    public sealed class JustificationAttribute : Attribute 
    {
        public string Reason { get; }
        
        /// <summary>
        /// Creates a justification attribute with the specified reason.
        /// </summary>
        /// <param name="reason">The reason this violation is acceptable.</param>
        public JustificationAttribute(string reason) => Reason = reason;
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\WrapperResult.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    public enum WrapperResult
    {
        Success = 0,
        InvalidFilter = 1,
        InvalidHandle = 2,
        InvalidParameter = 3,
        OperationAborted = 4,
        ElementNotFound = 5,
        BufferTooSmall = 6,
        Unknown = 99
    }
}
]]>
</file>
<file path="NetShaper.Benchmarks\Benchmarks.cs">
<![CDATA[
// NetShaper.Benchmarks/Benchmarks.cs
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;
using NetShaper.Engine;

namespace NetShaper.Benchmarks
{
    internal static class Program
    {
        private static void Main(string[] args)
        {
            // Run both throughput and latency/jitter benchmarks
            var summary = BenchmarkRunner.Run(typeof(Program).Assembly);
        }
    }

    [MemoryDiagnoser]
    [ThreadingDiagnoser]
    public class EngineBenchmarks
    {
        private const int Port = 55556;
        private const int PacketCount = 10000;

        private Engine.Engine _engine = null!;
        private CancellationTokenSource _cts = null!;
        private Task _captureTask = null!;
        private Socket _socket = null!;
        private IPacketLogger _logger = null!;
        private IPacketCapture _capture = null!;

        private byte[] _small = null!;
        private byte[] _medium = null!;
        private byte[] _large = null!;

        [GlobalSetup]
        public void Setup()
        {
            _small = new byte[64];
            _medium = new byte[512];
            _large = new byte[1400];

            _socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            _socket.Connect(IPAddress.Loopback, Port);

            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();

            _logger = provider.GetRequiredService<IPacketLogger>();
            _capture = provider.GetRequiredService<IPacketCapture>();

            Func<IPacketCapture> captureFactory = () => _capture;
            _engine = new Engine.Engine(_logger, captureFactory, threadCount: 1);
            _cts = new CancellationTokenSource();

            var result = _engine.Start($"outbound and udp.DstPort == {Port}", _cts.Token);
            if (result != StartResult.Success)
                throw new InvalidOperationException(result.ToString());

            _captureTask = Task.Factory.StartNew(
                static state =>
                {
                    var engine = (Engine.Engine)state!;
                    engine.RunCaptureLoop();
                },
                _engine,
                TaskCreationOptions.LongRunning);

            Thread.Sleep(200);
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _engine.Stop();
            _cts.Cancel();

            try { _captureTask.Wait(1000); } catch { }

            _engine.Dispose();
            _cts.Dispose();
            _socket.Dispose();
            _capture.Dispose();
        }

        [Benchmark(Description = "10k packets - 64 bytes")]
        public void SmallPackets()
        {
            for (int i = 0; i < PacketCount; i++)
            {
                _socket.Send(_small);
                if ((i & 255) == 0) Thread.Yield();
            }
        }

        [Benchmark(Description = "10k packets - 512 bytes")]
        public void MediumPackets()
        {
            for (int i = 0; i < PacketCount; i++)
            {
                _socket.Send(_medium);
                if ((i & 255) == 0) Thread.Yield();
            }
        }

        [Benchmark(Description = "10k packets - 1400 bytes")]
        public void LargePackets()
        {
            for (int i = 0; i < PacketCount; i++)
            {
                _socket.Send(_large);
                if ((i & 255) == 0) Thread.Yield();
            }
        }
    }
}
]]>
</file>
<file path="NetShaper.Benchmarks\LatencyJitterBenchmark.cs">
<![CDATA[
// NetShaper.Benchmarks/LatencyJitterBenchmark.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;

namespace NetShaper.Benchmarks
{
    /// <summary>
    /// Benchmark de latencia individual y jitter.
    /// Optimizado para hardware lento - expectativas realistas.
    /// </summary>
    [MemoryDiagnoser]
    [SimpleJob(warmupCount: 1, iterationCount: 3)]
    public class LatencyJitterBenchmark
    {
        private const int Port = 55558;
        private const int SampleCount = 500; // Reducido para hardware lento
        
        private IEngine _engine = null!;
        private CancellationTokenSource _cts = null!;
        private Task _captureTask = null!;
        private Socket _socket = null!;
        private byte[] _packet = null!;

        [GlobalSetup]
        public void Setup()
        {
            _packet = new byte[512];
            _socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            _socket.Connect(IPAddress.Loopback, Port);

            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();

            _engine = provider.GetRequiredService<IEngine>();
            _cts = new CancellationTokenSource();

            var result = _engine.Start($"outbound and udp.DstPort == {Port}", _cts.Token);
            if (result != StartResult.Success)
                throw new InvalidOperationException($"Start failed: {result}");

            _captureTask = Task.Run(() => _engine.RunCaptureLoop(), _cts.Token);

            // Warmup ligero
            for (int i = 0; i < 100; i++)
            {
                _socket.Send(_packet);
                Thread.Sleep(5); // Delay para no saturar
            }

            Thread.Sleep(500);
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _engine.Stop();
            _cts.Cancel();
            try { _captureTask.Wait(2000); } catch { }
            _engine.Dispose();
            _cts.Dispose();
            _socket.Dispose();
        }

        /// <summary>
        /// Mide latencia de procesamiento individual (send to processed).
        /// Envía 1 paquete, espera que se procese, mide tiempo total.
        /// </summary>
        [Benchmark(Description = "Individual Latency (500 samples)")]
        public LatencyStats MeasureIndividualLatency()
        {
            var latencies = new List<long>(SampleCount);

            for (int i = 0; i < SampleCount; i++)
            {
                long baseline = _engine.PacketCount;
                long start = Stopwatch.GetTimestamp();

                _socket.Send(_packet);

                // Esperar hasta que el paquete sea procesado
                while (_engine.PacketCount == baseline)
                {
                    Thread.SpinWait(50);
                }

                long end = Stopwatch.GetTimestamp();
                latencies.Add(end - start);

                // Pequeño delay entre mediciones para evitar saturación
                Thread.Sleep(2);
            }

            var result = CalculateLatencyStats(latencies);
            
            // Guardar en Desktop con ruta absoluta
            try
            {
                string resultsPath = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
                    "netshaper_latency_results.txt");
                File.AppendAllText(resultsPath, 
                    $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] LATENCY: {result}\n");
            }
            catch { /* Ignore file errors in benchmark */ }
            
            return result;
        }

        /// <summary>
        /// Mide jitter enviando paquetes a ritmo constante (100 PPS).
        /// </summary>
        [Benchmark(Description = "Jitter at 100 PPS")]
        public JitterStats MeasureJitterAt100Pps()
        {
            var latencies = new List<long>(SampleCount);
            long intervalTicks = Stopwatch.Frequency / 100; // 10ms interval = 100 PPS

            long nextSend = Stopwatch.GetTimestamp();

            for (int i = 0; i < SampleCount; i++)
            {
                long baseline = _engine.PacketCount;
                long start = Stopwatch.GetTimestamp();

                // Esperar hasta el momento exacto de envío
                while (Stopwatch.GetTimestamp() < nextSend)
                    Thread.SpinWait(10);

                _socket.Send(_packet);
                nextSend += intervalTicks;

                // Esperar procesamiento
                while (_engine.PacketCount == baseline)
                {
                    Thread.SpinWait(50);
                }

                long end = Stopwatch.GetTimestamp();
                latencies.Add(end - start);
            }

            var result = CalculateJitterStats(latencies);
            
            // Guardar en Desktop con ruta absoluta
            try
            {
                string resultsPath = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
                    "netshaper_latency_results.txt");
                File.AppendAllText(resultsPath, 
                    $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] JITTER: {result}\n");
            }
            catch { /* Ignore file errors in benchmark */ }
            
            return result;
        }

        private static LatencyStats CalculateLatencyStats(List<long> latencies)
        {
            latencies.Sort();
            double ToMicroseconds(long ticks) => (ticks * 1_000_000.0) / Stopwatch.Frequency;

            return new LatencyStats
            {
                P50_us = ToMicroseconds(latencies[latencies.Count / 2]),
                P95_us = ToMicroseconds(latencies[(int)(latencies.Count * 0.95)]),
                P99_us = ToMicroseconds(latencies[(int)(latencies.Count * 0.99)]),
                Min_us = ToMicroseconds(latencies[0]),
                Max_us = ToMicroseconds(latencies[^1]),
                Mean_us = ToMicroseconds((long)latencies.Average())
            };
        }

        private static JitterStats CalculateJitterStats(List<long> latencies)
        {
            double ToMicroseconds(long ticks) => (ticks * 1_000_000.0) / Stopwatch.Frequency;

            var mean = latencies.Average();
            var variance = latencies.Select(l => Math.Pow(l - mean, 2)).Average();
            var stdDev = Math.Sqrt(variance);

            var deltas = new List<double>();
            for (int i = 1; i < latencies.Count; i++)
            {
                deltas.Add(Math.Abs(latencies[i] - latencies[i - 1]));
            }

            deltas.Sort();

            return new JitterStats
            {
                StdDev_us = ToMicroseconds((long)stdDev),
                MaxJitter_us = ToMicroseconds((long)deltas.Max()),
                AvgJitter_us = ToMicroseconds((long)deltas.Average()),
                P95Jitter_us = ToMicroseconds((long)deltas[(int)(deltas.Count * 0.95)])
            };
        }
    }

    public struct LatencyStats
    {
        public double P50_us;
        public double P95_us;
        public double P99_us;
        public double Min_us;
        public double Max_us;
        public double Mean_us;

        public override string ToString() =>
            $"P50={P50_us:F0}μs P95={P95_us:F0}μs P99={P99_us:F0}μs (Min={Min_us:F0} Max={Max_us:F0})";
    }

    public struct JitterStats
    {
        public double StdDev_us;
        public double MaxJitter_us;
        public double AvgJitter_us;
        public double P95Jitter_us;

        public override string ToString() =>
            $"Avg={AvgJitter_us:F0}μs P95={P95Jitter_us:F0}μs Max={MaxJitter_us:F0}μs (σ={StdDev_us:F0})";
    }
}
]]>
</file>
<file path="NetShaper.Composition\ServiceCollectionExtensions.cs">
<![CDATA[
// NetShaper.Composition/ServiceCollectionExtensions.cs
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Infrastructure;
using NetShaper.Native;

namespace NetShaper.Composition
{
    /// <summary>
    /// Composition root for NetShaper dependency injection.
    /// This is the ONLY place where concrete implementations are wired to abstractions.
    /// </summary>
    [CompositionRoot]
    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// Registers all NetShaper core services including packet capture, logging, and engine.
        /// This method wires all concrete implementations to their abstractions.
        /// </summary>
        /// <param name="services">The service collection to add services to.</param>
        /// <returns>The service collection for chaining.</returns>
        public static IServiceCollection AddNetShaperServices(this IServiceCollection services)
        {
            // Register packet logger as singleton (maintains state across application lifetime)
            services.AddSingleton<IPacketLogger, RingBufferPacketLogger>();
            
            // Register packet capture as transient (new instance per engine)
            services.AddTransient<IPacketCapture, WinDivertAdapter>();
            
            // Register Engine as IEngine (83k PPS with 1 thread, minimal resources)
            // Factory pattern: creates fresh IPacketCapture instance per thread
            services.AddTransient<IEngine>(serviceProvider =>
            {
                var logger = serviceProvider.GetRequiredService<IPacketLogger>();
                
                // Factory to create IPacketCapture instances (one per thread in pool)
                Func<IPacketCapture> captureFactory = () => 
                    serviceProvider.GetRequiredService<IPacketCapture>();
                
                // Default: 1 thread (optimal for Celeron N5100, 83k PPS)
                // Future: make configurable via settings
                const int threadCount = 1;
                
                return new Engine.Engine(logger, captureFactory, threadCount);
            });
            
            return services;
        }
    }
}
]]>
</file>
<file path="NetShaper.Engine\ArrayPoolDiagnostics.cs">
<![CDATA[
// NetShaper.Engine/ArrayPoolDiagnostics.cs
using System.Diagnostics;
using System.Threading;

namespace NetShaper.Engine
{
    /// <summary>
    /// Diagnósticos para rastrear el balance de ArrayPool rent/return.
    /// Solo activo en builds DEBUG.
    /// </summary>
    internal static class ArrayPoolDiagnostics
    {
        private static int _rentCount;
        private static int _returnCount;

        public static void RecordRent()
        {
            Interlocked.Increment(ref _rentCount);
        }

        public static void RecordReturn()
        {
            Interlocked.Increment(ref _returnCount);
        }

        [Conditional("DEBUG")]
        public static void ValidateBalance()
        {
            // Simple read with memory barrier - good enough for DEBUG diagnostics
            // Potential race is acceptable since this is only for developer awareness
            int rents = Volatile.Read(ref _rentCount);
            int returns = Volatile.Read(ref _returnCount);
            
            Debug.Assert(rents == returns, 
                $"ArrayPool mismatch: Rent={rents}, Return={returns}");
        }
    }
}
]]>
</file>
<file path="NetShaper.Engine\Engine.cs">
<![CDATA[
// NetShaper.Engine/Engine.cs
using System;
using System.Runtime.CompilerServices;
using System.Threading;
using NetShaper.Abstractions;

namespace NetShaper.Engine
{
    /// <summary>
    /// Multi-threaded batch processing engine using WinDivertRecvEx.
    /// Achieves 83k PPS with 1 thread, 2.4x improvement over baseline.
    /// </summary>
    public sealed class Engine : IEngine
    {
        private readonly IPacketLogger _logger;
        private readonly Func<IPacketCapture> _captureFactory;
        private readonly int _threadCount;
        private CancellationTokenSource _cts;  // Not readonly - recreated on each Start()
        
        // Per-thread resources
        private readonly IPacketCapture[] _captures;
        private readonly byte[][] _buffers;
        private readonly Thread[] _threads;
        
        private readonly EngineTelemetry _telemetry;
        private int _isRunning;
        private int _disposed;
        
        private const int BufferSize = 128 * 1024; // 128KB for batch
        private const int BatchSize = 64; // Max packets per batch
        
        public Engine(IPacketLogger logger, Func<IPacketCapture> captureFactory, int threadCount)
        {
            if (threadCount <= 0 || threadCount > 16)
                throw new ArgumentOutOfRangeException(nameof(threadCount));
            
            _logger = logger;
            _captureFactory = captureFactory ?? throw new ArgumentNullException(nameof(captureFactory));
            _threadCount = threadCount;
            _cts = new CancellationTokenSource();
            _telemetry = new EngineTelemetry();
            
            // Initialize arrays
            _captures = new IPacketCapture[threadCount];
            _buffers = new byte[threadCount][];
            _threads = new Thread[threadCount];
            
            // Pre-allocate buffers and create capture instances
            for (int i = 0; i < threadCount; i++)
            {
                _captures[i] = _captureFactory();
                _buffers[i] = System.Buffers.ArrayPool<byte>.Shared.Rent(BufferSize);
                ArrayPoolDiagnostics.RecordRent();
            }
        }
        
        // IEngine interface implementation
        public bool IsRunning => Interlocked.CompareExchange(ref _isRunning, 0, 0) == 1;
        public long PacketCount => _telemetry.PacketsProcessed;
        
        public StartResult Start(string filter, CancellationToken ct = default)
        {
            // Link external cancellation token to internal CTS
            if (ct != default && ct.CanBeCanceled)
            {
                ct.Register(() => _cts.Cancel());
            }
            
            return Start(filter);
        }
        
        public EngineResult RunCaptureLoop()
        {
            // Engine manages threads internally, so this is a no-op
            // Threads are already running after Start()
            // Wait for cancellation or Stop()
            while (IsRunning && !_cts.Token.IsCancellationRequested)
            {
                Thread.Sleep(100);
            }
            
            return EngineResult.Success;
        }
        
        public StartResult Start(string filter)
        {
            if (Interlocked.CompareExchange(ref _isRunning, 1, 0) != 0)
                return StartResult.AlreadyRunning;
            
            // Dispose old CTS if exists and create fresh one
            _cts?.Dispose();
            _cts = new CancellationTokenSource();
            
            // Reset telemetry for new session
            _telemetry.Reset();
            
            // Open ALL handles with the same filter
            for (int i = 0; i < _threadCount; i++)
            {
                CaptureResult result = _captures[i].Open(filter);
                if (result != CaptureResult.Success)
                {
                    Interlocked.Exchange(ref _isRunning, 0);
                    return StartResult.OpenFailed;
                }
            }
            
            _telemetry.Reset();
            
            // Launch worker threads
            for (int i = 0; i < _threadCount; i++)
            {
                int threadIdx = i;
                _threads[threadIdx] = new Thread(() => ProcessLoopWorker(threadIdx))
                {
                    IsBackground = true,
                    Name = $"BatchWorker-{threadIdx}",
                    Priority = ThreadPriority.AboveNormal
                };
                _threads[threadIdx].Start();
            }
            
            return StartResult.Success;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool ShouldStop() => _cts.Token.IsCancellationRequested;
        
        private void ProcessLoopWorker(int threadIdx)
        {
            IPacketCapture capture = _captures[threadIdx];
            byte[] bufferArray = _buffers[threadIdx];
            
            // stackalloc metadata array for batch (zero allocation)
            Span<PacketMetadata> metadataBatch = stackalloc PacketMetadata[BatchSize];
            
            // Local counters
            long localPackets = 0;
            long localRecvErrors = 0;
            long localSendErrors = 0;
            long localInvalidPackets = 0;
            
            // For periodic telemetry updates (so UI shows real-time counts)
            const long TelemetryFlushInterval = 1000;
            
            try
            {
                while (true)
                {
                    if (ShouldStop())
                        break;
                    
                    Span<byte> buffer = bufferArray.AsSpan(0, BufferSize);
                    
                    // Receive batch of packets
                    CaptureResult recv = capture.ReceiveBatch(
                        buffer,
                        metadataBatch,
                        out uint totalBytes,
                        out int packetCount);
                    
                    if (recv != CaptureResult.Success)
                    {
                        if (recv == CaptureResult.InvalidHandle || recv == CaptureResult.OperationAborted)
                            break;
                        
                        localRecvErrors++;
                        continue;
                    }
                    
                    // Process batch using native-parsed lengths
                    ProcessBatch(capture, buffer, metadataBatch, packetCount,
                        ref localPackets, ref localSendErrors, ref localInvalidPackets);
                    
                    // Periodic telemetry flush for real-time UI updates
                    if (localPackets >= TelemetryFlushInterval)
                    {
                        _telemetry.AddPackets(localPackets);
                        _telemetry.AddRecvErrors(localRecvErrors);
                        _telemetry.AddSendErrors(localSendErrors);
                        _telemetry.AddInvalidPackets(localInvalidPackets);
                        
                        localPackets = 0;
                        localRecvErrors = 0;
                        localSendErrors = 0;
                        localInvalidPackets = 0;
                    }
                }
            }
            catch (Exception)
            {
                localRecvErrors++;
            }
            finally
            {
                // Final flush of any remaining counters
                if (localPackets > 0) _telemetry.AddPackets(localPackets);
                if (localRecvErrors > 0) _telemetry.AddRecvErrors(localRecvErrors);
                if (localSendErrors > 0) _telemetry.AddSendErrors(localSendErrors);
                if (localInvalidPackets > 0) _telemetry.AddInvalidPackets(localInvalidPackets);
            }
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ProcessBatch(
            IPacketCapture capture,
            Span<byte> buffer,
            Span<PacketMetadata> metadata,
            int count,
            ref long packetsProcessed,
            ref long sendErrors,
            ref long invalidPackets)
        {
            uint offset = 0;
            
            for (int i = 0; i < count; i++)
            {
                ref PacketMetadata meta = ref metadata[i];
                uint packetLen = meta.Length;
                
                if (packetLen == 0 || packetLen > BufferSize || offset + packetLen > buffer.Length)
                {
                    invalidPackets++;
                    break;
                }
                
                Span<byte> packet = buffer.Slice((int)offset, (int)packetLen);
                
                // Calculate checksums and send individually
                capture.CalculateChecksums(packet, packetLen, ref meta);
                
                CaptureResult sendResult = capture.Send(packet, ref meta);
                if (sendResult == CaptureResult.Success)
                {
                    packetsProcessed++;
                }
                else if (sendResult != CaptureResult.InvalidHandle)
                {
                    sendErrors++;
                }
                
                offset += packetLen;
            }
        }
        
        public void Stop()
        {
            _cts.Cancel();
            
            // Unblock WinDivertRecv calls
            if (_captures != null)
            {
                foreach (var capture in _captures)
                {
                    try { capture?.Shutdown(); } catch { /* best effort */ }
                }
            }
            
            // Wait for threads
            bool allJoined = true;
            for (int i = 0; i < _threadCount; i++)
            {
                if (_threads[i] != null && _threads[i].IsAlive)
                {
                    if (!_threads[i].Join(2000))
                        allJoined = false;
                }
            }
            
            Interlocked.Exchange(ref _isRunning, 0);
        }
        
        public long TotalPacketsProcessed => _telemetry.PacketsProcessed;
        public int ThreadCount => _threadCount;
        
        public void Dispose()
        {
            if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 0)
            {
                Stop();
                _cts.Dispose();
                
                // Cleanup per-thread resources
                for (int i = 0; i < _threadCount; i++)
                {
                    // Return buffer
                    if (_buffers[i] != null)
                    {
                        System.Buffers.ArrayPool<byte>.Shared.Return(_buffers[i]);
                        ArrayPoolDiagnostics.RecordReturn();
                    }
                    
                    // Dispose capture handle
                    (_captures[i] as IDisposable)?.Dispose();
                }
            }
        }
    }
}
]]>
</file>
<file path="NetShaper.Engine\EngineTelemetry.cs">
<![CDATA[
// NetShaper.Engine/EngineTelemetry.cs
using System.Runtime.CompilerServices;
using System.Threading;

namespace NetShaper.Engine
{
    internal sealed class EngineTelemetry
    {
        private long _packetsProcessed;
        private long _recvErrors;
        private long _sendErrors;
        private long _invalidPackets;
        private long _consecutiveErrors;

        // Propiedades con Volatile.Read para lecturas cross-thread seguras
        public long PacketsProcessed => Volatile.Read(ref _packetsProcessed);
        public long RecvErrors => Volatile.Read(ref _recvErrors);
        public long SendErrors => Volatile.Read(ref _sendErrors);
        public long InvalidPackets => Volatile.Read(ref _invalidPackets);
        public long ConsecutiveErrors => Volatile.Read(ref _consecutiveErrors);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordPacket()
        {
            Interlocked.Increment(ref _packetsProcessed);
            Interlocked.Exchange(ref _consecutiveErrors, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordRecvError()
        {
            Interlocked.Increment(ref _recvErrors);
            Interlocked.Increment(ref _consecutiveErrors);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordSendError()
        {
            Interlocked.Increment(ref _sendErrors);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordInvalidPacket()
        {
            Interlocked.Increment(ref _invalidPackets);
        }

        public void AddPackets(long count)
        {
            Interlocked.Add(ref _packetsProcessed, count);
        }

        public void AddRecvErrors(long count)
        {
            Interlocked.Add(ref _recvErrors, count);
            Interlocked.Add(ref _consecutiveErrors, count);
        }

        public void AddSendErrors(long count)
        {
            Interlocked.Add(ref _sendErrors, count);
        }

        public void AddInvalidPackets(long count)
        {
            Interlocked.Add(ref _invalidPackets, count);
        }

        public void Reset()
        {
            Interlocked.Exchange(ref _packetsProcessed, 0);
            Interlocked.Exchange(ref _recvErrors, 0);
            Interlocked.Exchange(ref _sendErrors, 0);
            Interlocked.Exchange(ref _invalidPackets, 0);
            Interlocked.Exchange(ref _consecutiveErrors, 0);
        }
    }
}
]]>
</file>
<file path="NetShaper.Infrastructure\ConsolePacketLogger.cs">
<![CDATA[
using System;
using System.Diagnostics;
using NetShaper.Abstractions;

namespace NetShaper.Infrastructure
{
    public sealed class ConsolePacketLogger : IPacketLogger
    {
        private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;

        public void Log(in PacketLogEntry entry)
        {
            long ticks = (long)(entry.Timestamp * TickFrequency);
            TimeSpan elapsed = new TimeSpan(ticks);

            string levelStr = entry.Level switch
            {
                LogLevel.Info => "INFO",
                LogLevel.Warning => "WARN",
                LogLevel.Error => "ERROR",
                _ => "UNKN"
            };

            string codeStr = entry.Code switch
            {
                LogCode.EngineStarted => "Engine Started",
                LogCode.EngineStopped => "Engine Stopped",
                LogCode.PacketProcessed => "Packet Processed",
                LogCode.RecvFailed => "Recv Failed",
                LogCode.SendFailed => "Send Failed",
                LogCode.InvalidPacket => "Invalid Packet",
                LogCode.OperationAborted => "Operation Aborted",
                LogCode.InvalidHandle => "Invalid Handle",
                LogCode.InvalidParameter => "Invalid Parameter",
                _ => "Unknown"
            };

            Console.WriteLine($"[{elapsed.TotalSeconds:F3}s] [{levelStr}] {codeStr} (Value: {entry.Value})");
        }
    }
}
]]>
</file>
<file path="NetShaper.Infrastructure\RingBufferPacketLogger.cs">
<![CDATA[
using System;
using System.Threading;
using NetShaper.Abstractions;

namespace NetShaper.Infrastructure
{
    public sealed class RingBufferPacketLogger : IPacketLogger
    {
        private readonly PacketLogEntry[] _buffer;
        private readonly int _mask;
        private int _index;

        public RingBufferPacketLogger(int powerOfTwoSize = 4096)
        {
            if (powerOfTwoSize <= 0)
                throw new ArgumentOutOfRangeException(nameof(powerOfTwoSize), powerOfTwoSize, "Size must be positive");

            if ((powerOfTwoSize & (powerOfTwoSize - 1)) != 0)
                throw new ArgumentException($"Size must be a power of two. Provided: {powerOfTwoSize}", nameof(powerOfTwoSize));

            _buffer = new PacketLogEntry[powerOfTwoSize];
            _mask = powerOfTwoSize - 1;
            _index = -1;
        }

        public void Log(in PacketLogEntry entry)
        {
            int i = Interlocked.Increment(ref _index) & _mask;
            _buffer[i] = entry;
        }

        public PacketLogEntry[] Snapshot()
        {
            return (PacketLogEntry[])_buffer.Clone();
        }
    }
}
]]>
</file>
<file path="NetShaper.Native\NativeMethods.cs">
<![CDATA[
// NetShaper.Native\NativeMethods.cs
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace NetShaper.Native
{
    public static partial class NativeMethods
    {
        private const string DllName = "WinDivert.dll";

        public const int LayerNetwork = 0;
        public const int WinDivertShutdownRecv = 1;
        public const int WinDivertShutdownSend = 2;
        public const int WinDivertShutdownBoth = 3;

        [LibraryImport(DllName, EntryPoint = "WinDivertOpen", SetLastError = true, StringMarshalling = StringMarshalling.Utf8)]
        [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })]
        public static partial WinDivertHandle WinDivertOpen(
            string filter,
            int layer,
            short priority,
            long flags);

        [LibraryImport(DllName, EntryPoint = "WinDivertShutdown", SetLastError = true)]
        [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static partial bool WinDivertShutdown(
            WinDivertHandle handle, 
            int mode);
    }
}
]]>
</file>
<file path="NetShaper.Native\WinDivertAdapter.cs">
<![CDATA[
// NetShaper.Native/WinDivertAdapter.cs
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NetShaper.Abstractions;

namespace NetShaper.Native
{
    public sealed partial class WinDivertAdapter : IPacketCapture
    {
        private const int MaxFilterLength = PacketCaptureConstants.MaxFilterLength;
        private const int ShutdownRecv = 1;

        private WinDivertHandle? _handle;
        private int _disposed;

        static WinDivertAdapter()
        {
            ValidateStructLayout();
        }

        public CaptureResult Open(string filter)
        {
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return CaptureResult.InvalidHandle;
            if (string.IsNullOrWhiteSpace(filter))
                return CaptureResult.InvalidFilter;
            if (filter.Length > MaxFilterLength)
                return CaptureResult.InvalidFilter;
            if (_handle != null && !_handle.IsInvalid)
                return CaptureResult.InvalidHandle;

            WinDivertHandle? handle = null;

            try
            {
                handle = WinDivertOpenNative(filter, 0, 0, 0);
                if (handle.IsInvalid)
                {
                    int error = Marshal.GetLastWin32Error();
                    // REMOVED: Console.WriteLine to prevent allocations in hot-path
                    // Error code is already returned via MapError(error) below
                    handle.Dispose();
                    return MapError(error);
                }

                _handle = handle;
                return CaptureResult.Success;
            }
            catch (Exception)
            {
                // REMOVED: Console.WriteLine to prevent allocations in hot-path
                // Exception is re-thrown to caller for proper handling
                handle?.Dispose();
                throw;
            }
        }

        public unsafe CaptureResult Receive(
            Span<byte> buffer,
            out uint length,
            ref PacketMetadata metadata)
        {
            length = 0;
            
            CaptureResult validation = ValidateHandle(out WinDivertHandle? handle);
            if (validation != CaptureResult.Success)
                return validation;
            
            if (buffer.IsEmpty)
                return CaptureResult.BufferTooSmall;

            try
            {
                fixed (byte* pBuf = buffer)
                {
                    WinDivertAddress addr = ToWinDivertAddress(ref metadata);
                    WinDivertAddress* pAddr = &addr;

                    bool success = WinDivertRecvNative(
                        handle,
                        pBuf,
                        (uint)buffer.Length,
                        out length,
                        pAddr);

                    if (!success)
                        return MapError(Marshal.GetLastWin32Error());

                    metadata = FromWinDivertAddress(ref addr);
                    return CaptureResult.Success;
                }
            }
            catch (ObjectDisposedException)
            {
                // Handle was disposed during shutdown between our null check and usage
                // This is expected during rapid stop sequences - treat as InvalidHandle
                return CaptureResult.InvalidHandle;
            }
        }

        public unsafe CaptureResult ReceiveBatch(
            Span<byte> buffer,
            Span<PacketMetadata> metadataArray,
            out uint batchLength,
            out int packetCount)
        {
            batchLength = 0;
            packetCount = 0;
            
            CaptureResult validation = ValidateHandle(out WinDivertHandle? handle);
            if (validation != CaptureResult.Success)
                return validation;
            
            if (buffer.IsEmpty || metadataArray.IsEmpty)
                return CaptureResult.BufferTooSmall;

            try
            {
                const int MaxBatchSize = 64;
                int maxPackets = Math.Min(metadataArray.Length, MaxBatchSize);
                
                // Stack-allocate WinDivertAddress array for batch
                WinDivertAddress* pAddrArray = stackalloc WinDivertAddress[maxPackets];
                
                fixed (byte* pBuf = buffer)
                {
                    uint readLen = 0;  // ← CORRECTED: was ulong
                    uint addrLen = (uint)(maxPackets * sizeof(WinDivertAddress));
                    
                    // Call WinDivertRecvEx (batch mode)
                    bool success = WinDivertRecvExNative(
                        handle,
                        pBuf,
                        (uint)buffer.Length,
                        &readLen,  // ← CORRECTED: now uint* instead of ulong*
                        0,  // flags = 0 (synchronous)
                        pAddrArray,
                        &addrLen,
                        null);  // pOverlapped = null (synchronous)

                    if (!success)
                        return MapError(Marshal.GetLastWin32Error());

                    batchLength = readLen;  // ← No cast needed now
                    packetCount = (int)(addrLen / sizeof(WinDivertAddress));
                    
                    // Parse IP headers to extract packet lengths
                    // WinDivert packs packets tightly: [Pkt1][Pkt2][Pkt3]...
                    uint offset = 0;
                    for (int i = 0; i < packetCount; i++)
                    {
                        ref PacketMetadata meta = ref metadataArray[i];
                        ref WinDivertAddress addr = ref pAddrArray[i];
                        
                        // Convert WinDivertAddress to PacketMetadata
                        meta = FromWinDivertAddress(ref addr);
                        
                        // Parse IP header to get packet length
                        // IP header: byte 0 = version+IHL
                        // For IPv4: bytes 2-3 = Total Length (big-endian)
                        // For IPv6: bytes 4-5 = Payload Length (big-endian)
                        
                        if (offset >= readLen)
                        {
                            // Safety: prevent reading beyond buffer
                            meta.Length = 0;
                            break;
                        }
                        
                        byte* pPacket = pBuf + offset;
                        byte versionIHL = pPacket[0];
                        byte version = (byte)(versionIHL >> 4);
                        
                        uint packetLength;
                        if (version == 4)
                        {
                            // IPv4: Total Length at offset 2-3 (big-endian)
                            packetLength = (uint)((pPacket[2] << 8) | pPacket[3]);
                        }
                        else if (version == 6)
                        {
                            // IPv6: Payload Length at offset 4-5 (big-endian) + 40 bytes header
                            uint payloadLen = (uint)((pPacket[4] << 8) | pPacket[5]);
                            packetLength = 40 + payloadLen;
                        }
                        else
                        {
                            // Unknown version, skip this packet
                            meta.Length = 0;
                            break;
                        }
                        
                        meta.Length = packetLength;
                        offset += packetLength;
                    }

                    return CaptureResult.Success;
                }
            }
            catch (ObjectDisposedException)
            {
                return CaptureResult.InvalidHandle;
            }
        }

        public unsafe CaptureResult Send(
            ReadOnlySpan<byte> buffer,
            ref PacketMetadata metadata)
        {
            CaptureResult validation = ValidateHandle(out WinDivertHandle? handle);
            if (validation != CaptureResult.Success)
                return validation;
            
            if (buffer.IsEmpty)
                return CaptureResult.InvalidParameter;

            try
            {
                fixed (byte* pBuf = buffer)
                {
                    WinDivertAddress addr = ToWinDivertAddress(ref metadata);
                    WinDivertAddress* pAddr = &addr;

                    bool success = WinDivertSendNative(
                        handle,
                        pBuf,
                        (uint)buffer.Length,
                        out uint _,
                        pAddr);

                    if (!success)
                        return MapError(Marshal.GetLastWin32Error());

                    return CaptureResult.Success;
                }
            }
            catch (ObjectDisposedException)
            {
                // Handle was disposed during shutdown between our null check and usage
                // This is expected during rapid stop sequences - treat as InvalidHandle
                return CaptureResult.InvalidHandle;
            }
        }

        public void Shutdown()
        {
            // NOTE: Do NOT check _disposed here
            // Shutdown is a temporary pause operation, not final destruction
            // It must work even if the instance will be disposed later
            // This allows proper Start/Stop reentrancy as per rules v2 §71
            
            WinDivertHandle? handle = _handle;
            if (handle == null || handle.IsInvalid)
                return;

            // Shutdown reception first
            WinDivertShutdownNative(handle, ShutdownRecv);
            
            // Close and release the handle to allow restart
            _handle = null;
            handle.Dispose();
        }

        public unsafe void CalculateChecksums(
            Span<byte> buffer,
            uint length,
            ref PacketMetadata metadata)
        {
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return;
            if (buffer.IsEmpty || length == 0)
                return;

            fixed (byte* pBuf = buffer)
            {
                WinDivertAddress addr = ToWinDivertAddress(ref metadata);
                WinDivertAddress* pAddr = &addr;

                WinDivertHelperCalcChecksumsNative(pBuf, length, pAddr, 0);
            }
        }

        public void Dispose()
		{
			if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 0)
			{
				if (_handle != null && !_handle.IsInvalid)
				{
					// Shutdown orderly antes de cerrar handle
					WinDivertShutdownNative(_handle, 0); // 0 = SHUT_RDWR
					_handle.Dispose();
				}
			}
		}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private CaptureResult ValidateHandle(out WinDivertHandle? handle)
        {
            handle = null;
            
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return CaptureResult.InvalidHandle;

            handle = _handle;
            if (handle == null || handle.IsInvalid)
                return CaptureResult.InvalidHandle;

            return CaptureResult.Success;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static CaptureResult MapError(int code)
        {
            return code switch
            {
                995 => CaptureResult.OperationAborted,
                6 => CaptureResult.InvalidHandle,
                87 => CaptureResult.InvalidParameter,
                1168 => CaptureResult.ElementNotFound,
                _ => CaptureResult.Unknown
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static WinDivertAddress ToWinDivertAddress(ref PacketMetadata metadata)
        {
            return new WinDivertAddress
            {
                Timestamp = metadata.Timestamp,
                IfIdx = metadata.InterfaceIndex,
                SubIfIdx = metadata.SubInterfaceIndex,
                Direction = metadata.Direction,
                Loopback = metadata.Loopback,
                Impostor = metadata.Impostor,
                IPChecksum = metadata.IpChecksum,
                TCPChecksum = metadata.TcpChecksum,
                UDPChecksum = metadata.UdpChecksum,
                Reserved1 = metadata.Reserved1,
                Reserved2 = metadata.Reserved2
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static PacketMetadata FromWinDivertAddress(ref WinDivertAddress addr)
        {
            return new PacketMetadata
            {
                Timestamp = addr.Timestamp,
                InterfaceIndex = addr.IfIdx,
                SubInterfaceIndex = addr.SubIfIdx,
                Direction = addr.Direction,
                Loopback = addr.Loopback,
                Impostor = addr.Impostor,
                IpChecksum = addr.IPChecksum,
                TcpChecksum = addr.TCPChecksum,
                UdpChecksum = addr.UDPChecksum,
                Reserved1 = addr.Reserved1,
                Reserved2 = addr.Reserved2
            };
        }

        [Conditional("DEBUG")]
        private static void ValidateStructLayout()
        {
            Debug.Assert(Marshal.SizeOf<WinDivertAddress>() == 28,
                "WinDivertAddress size mismatch - expected 28 bytes");
            Debug.Assert(Marshal.OffsetOf<WinDivertAddress>(nameof(WinDivertAddress.Timestamp)).ToInt32() == 0,
                "WinDivertAddress.Timestamp offset incorrect");
            Debug.Assert(Marshal.OffsetOf<WinDivertAddress>(nameof(WinDivertAddress.IfIdx)).ToInt32() == 8,
                "WinDivertAddress.IfIdx offset incorrect");
        }

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertOpen", StringMarshalling = StringMarshalling.Utf8)]
        private static partial WinDivertHandle WinDivertOpenNative(
            string filter,
            int layer,
            short priority,
            ulong flags);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertRecv")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static unsafe partial bool WinDivertRecvNative(
            WinDivertHandle handle,
            byte* pPacket,
            uint packetLen,
            out uint readLen,
            WinDivertAddress* pAddr);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertRecvEx")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static unsafe partial bool WinDivertRecvExNative(
            WinDivertHandle handle,
            byte* pPacket,
            uint packetLen,
            uint* pRecvLen,      // ← CORRECTED: was ulong*, should be uint*
            ulong flags,
            WinDivertAddress* pAddr,
            uint* pAddrLen,      // ← CORRECTED: Input/Output, size in BYTES (not element count)
            void* pOverlapped);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertSend")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static unsafe partial bool WinDivertSendNative(
            WinDivertHandle handle,
            byte* pPacket,
            uint packetLen,
            out uint writeLen,
            WinDivertAddress* pAddr);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertShutdown")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static partial bool WinDivertShutdownNative(
            WinDivertHandle handle,
            int how);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertHelperCalcChecksums")]
        private static unsafe partial void WinDivertHelperCalcChecksumsNative(
            byte* pPacket,
            uint packetLen,
            WinDivertAddress* pAddr,
            ulong flags);
    }
}
]]>
</file>
<file path="NetShaper.Native\WinDivertAddress.cs">
<![CDATA[
// NetShaper.Native/WinDivertAddress.cs
using System.Runtime.InteropServices;

namespace NetShaper.Native
{
    /// <summary>
    /// Internal WinDivert address structure.
    /// This is an implementation detail specific to WinDivert and should not leak to abstractions.
    /// Layout matches WINDIVERT_ADDRESS (WinDivert 2.2).
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct WinDivertAddress
    {
        public long Timestamp;
        public uint IfIdx;
        public uint SubIfIdx;
        public byte Direction;
        public byte Loopback;
        public byte Impostor;
        public byte IPChecksum;
        public byte TCPChecksum;
        public byte UDPChecksum;
        public ushort Reserved1;
        public uint Reserved2;
    }
}
]]>
</file>
<file path="NetShaper.Native\WinDivertHandle.cs">
<![CDATA[
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;

namespace NetShaper.Native
{
    public sealed partial class WinDivertHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        public WinDivertHandle() : base(true) { }

        protected override bool ReleaseHandle()
        {
            return WinDivertClose(handle);
        }

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertClose", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static partial bool WinDivertClose(IntPtr handle);
    }

    // WinDivertAddress movido a NetShaper.Abstractions
}
]]>
</file>
<file path="NetShaper.StressTest\PerformanceTests.cs">
<![CDATA[
// NetShaper.StressTest/PerformanceTests.cs
using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Abstractions;

namespace NetShaper.StressTest
{
    /// <summary>
    /// Unified performance tests for NetShaper Engine with configurable threads.
    /// </summary>
    internal static class PerformanceTests
    {
        private const int PerformancePort = 55555;
        private const int PacketCount = 200_000;
        private const int WarmupMs = 500;
        private const int TestDuration = 2000;

        public static async Task RunPerformanceTestAsync(int threadCount)
        {
            Console.WriteLine($">>> NetShaper Performance Test ({threadCount} thread{(threadCount > 1 ? "s" : "")}) <<<");
            Console.Write("Calentando... ");

            using var engine = TestServiceFactory.CreateEngine(threadCount);

            var result = engine.Start($"outbound and udp.DstPort == {PerformancePort}");
            if (result != StartResult.Success)
            {
                Console.WriteLine($"❌ Error: {result}");
                return;
            }

            Console.WriteLine("OK");
            await Task.Delay(WarmupMs);

            // Telemetry baseline
            long packetsBefore = engine.PacketCount;
            long gen0Before = GC.CollectionCount(0);

            // Traffic generation
            Console.WriteLine($"Enviando {PacketCount:N0} paquetes mixtos...");
            
            var sw = Stopwatch.StartNew();
            await GenerateTrafficAsync(PacketCount, PerformancePort);
            sw.Stop();

            // Wait for processing
            await Task.Delay(TestDuration);
            engine.Stop();

            // Calculate results
            long packetsProcessed = engine.PacketCount - packetsBefore;
            long gen0After = GC.CollectionCount(0);
            int gen0Collections = (int)(gen0After - gen0Before);

            double pps = packetsProcessed / (sw.ElapsedMilliseconds / 1000.0);
            
            // Expected PPS calculation
            int expectedSingleThread = 83_000;
            double expectedPPS = threadCount == 1 ? expectedSingleThread : expectedSingleThread * 0.98; // slight degradation with more threads
            double efficiency = (pps / expectedPPS) * 100.0;

            // Display results
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine($"RESULTS ({threadCount} thread{(threadCount > 1 ? "s" : "")}):");
            Console.WriteLine($"PPS: {pps:N0}");
            Console.WriteLine($"Expected PPS: {expectedPPS:N0}");
            Console.WriteLine($"Efficiency: {efficiency:F1}%");
            Console.WriteLine($"GC Gen0: {gen0Collections}");
            Console.WriteLine($"Packets Processed: {packetsProcessed:N0}");
            Console.WriteLine("────────────────────────────────────────");

            // Verdicts
            if (gen0Collections == 0)
                Console.WriteLine("✅ ZERO ALLOC CONFIRMED");
            else
                Console.WriteLine($"⚠️  {gen0Collections} Gen0 collections detected");

            if (efficiency >= 90)
                Console.WriteLine("✅ EXCELLENT PERFORMANCE (≥90%)");
            else if (efficiency >= 70)
                Console.WriteLine("✅ GOOD PERFORMANCE (≥70%)");
            else if (efficiency >= 50)
                Console.WriteLine("⚠️ MODERATE PERFORMANCE (50-70%)");
            else
                Console.WriteLine("❌ POOR PERFORMANCE (<50%)");

            Console.WriteLine("════════════════════════════════════════");
        }

        private static async Task GenerateTrafficAsync(int count, int port)
        {
            await Task.Run(() =>
            {
                using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                var endpoint = new IPEndPoint(IPAddress.Loopback, port);
                
                byte[] small = new byte[64];
                byte[] medium = new byte[512];
                byte[] large = new byte[1400];

                for (int i = 0; i < count; i++)
                {
                    byte[] payload = (i % 3) switch
                    {
                        0 => small,
                        1 => medium,
                        _ => large
                    };
                    
                    socket.SendTo(payload, endpoint);
                    
                    if ((i & 255) == 0)
                        Thread.Yield();
                }
            });
        }
    }
}
]]>
</file>
<file path="NetShaper.StressTest\Program.cs">
<![CDATA[
using System;
using System.Threading.Tasks;

namespace NetShaper.StressTest
{
    internal static class Program
    {
        private static async Task<int> Main(string[] args)
        {
            Console.OutputEncoding = System.Text.Encoding.UTF8;
            Console.Title = "NetShaper Performance Tests";

            // Command line usage: dotnet run [threads|stability]
            // Example: dotnet run 4
            // Example: dotnet run stability
            if (args.Length > 0)
            {
                if (args[0].ToLowerInvariant() == "stability")
                {
                    RealTests.RunStabilityReal();
                    return 0;
                }
                else if (int.TryParse(args[0], out int threads) && threads >= 1 && threads <= 16)
                {
                    await PerformanceTests.RunPerformanceTestAsync(threads);
                    return 0;
                }
                else
                {
                    Console.WriteLine($"Invalid argument: {args[0]}");
                    Console.WriteLine("Usage: dotnet run [threads|stability]");
                    Console.WriteLine("  dotnet run 4           - Run with 4 threads");
                    Console.WriteLine("  dotnet run stability   - Run stability test (10000 cycles)");
                    return 1;
                }
            }

            // Interactive mode
            while (true)
            {
                Console.Clear();
                Console.WriteLine("════════════════════════════════════════");
                Console.WriteLine("   NetShaper Performance Test Suite");
                Console.WriteLine("════════════════════════════════════════");
                Console.WriteLine();
                Console.WriteLine("Selecciona un test:");
                Console.WriteLine();
                Console.WriteLine("1-16  = Performance Test (N threads)");
                Console.WriteLine("        1 = Single thread (83k PPS)");
                Console.WriteLine("        4 = Quad thread (~81k PPS)");
                Console.WriteLine();
                Console.WriteLine("S     = Stability Test (10,000 Start/Stop cycles)");
                Console.WriteLine();
                Console.WriteLine("0     = Salir");
                Console.Write("\nOpción: ");

                var input = Console.ReadLine()?.Trim();
                
                if (input == "0")
                    return 0;

                if (input?.ToUpperInvariant() == "S")
                {
                    Console.WriteLine();
                    RealTests.RunStabilityReal();
                    Console.WriteLine();
                    Console.WriteLine("Presiona cualquier tecla para continuar...");
                    Console.ReadKey(true);
                }
                else if (int.TryParse(input, out int threadCount) && threadCount >= 1 && threadCount <= 16)
                {
                    Console.WriteLine();
                    await PerformanceTests.RunPerformanceTestAsync(threadCount);
                    
                    Console.WriteLine();
                    Console.WriteLine("Presiona cualquier tecla para continuar...");
                    Console.ReadKey(true);
                }
                else
                {
                    Console.WriteLine("Número inválido. Debe ser entre 1 y 16.");
                    Console.ReadKey(true);
                }
            }
        }
    }
}
]]>
</file>
<file path="NetShaper.StressTest\RealTests.cs">
<![CDATA[
// NetShaper.StressTest/RealTests.cs
using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Engine;
using NetShaper.Abstractions;

namespace NetShaper.StressTest
{
    static class RealTests
    {
        private const int PerformancePort = 55555;
        private const int WarmupPackets = 200;
        private const int MeasurementPackets = 200_000;
        private const int BurstSize = 5000;
        private const int BurstCount = 10;

        public static void RunStabilityReal()
        {
            Console.WriteLine(">>> INICIANDO TEST DE ESTABILIDAD REAL (uso correcto) <<<");
            int cycles = 10000;
            int totalFallos = 0;
            int startFailures = 0;
            int captureLoopFailures = 0;
            int exceptionFailures = 0;
            var failedCycles = new List<int>();
            
            var sw = Stopwatch.StartNew();
            for (int i = 1; i <= cycles; i++)
            {
                FailureType failure = RunSingleCycle(i);
                
                if (failure != FailureType.None)
                {
                    totalFallos++;
                    failedCycles.Add(i);
                    
                    switch (failure)
                    {
                        case FailureType.StartFailed:
                            startFailures++;
                            break;
                        case FailureType.CaptureLoopFailed:
                            captureLoopFailures++;
                            break;
                        case FailureType.Exception:
                            exceptionFailures++;
                            break;
                    }
                }
                
                if (i % 100 == 0) Console.Write(".");
            }

            sw.Stop();
            Console.WriteLine("\n");
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine("RESUMEN ESTABILIDAD REAL:");
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine($"Tiempo total: {sw.ElapsedMilliseconds} ms");
            Console.WriteLine($"Ciclos ejecutados: {cycles:N0}");
            Console.WriteLine($"Fallos totales: {totalFallos}");
            
            if (totalFallos > 0)
            {
                Console.WriteLine("\nFALLOS POR CATEGORÍA:");
                Console.WriteLine($"  - Start failures:       {startFailures}");
                Console.WriteLine($"  - CaptureLoop failures: {captureLoopFailures}");
                Console.WriteLine($"  - Exceptions:           {exceptionFailures}");
                
                Console.WriteLine($"\nTasa de fallo: {(totalFallos * 100.0 / cycles):F3}%");
                Console.WriteLine($"\nCiclos con fallos: {string.Join(", ", failedCycles.Take(20))}");
                if (failedCycles.Count > 20)
                    Console.WriteLine($"  ... y {failedCycles.Count - 20} más");
            }
            
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine(totalFallos == 0 ? "✅ ESTABLE" : "❌ INESTABLE");
            Console.WriteLine("═══════════════════════════════════════════════════════");
        }
        
        private enum FailureType
        {
            None,
            StartFailed,
            CaptureLoopFailed,
            Exception
        }

        private static FailureType RunSingleCycle(int ciclo)
        {
            try
            {
                using var engine = TestServiceFactory.CreateEngine();
                using var cts = new CancellationTokenSource();

                StartResult startResult = engine.Start("ip", cts.Token);
                if (startResult != StartResult.Success)
                {
                    Console.WriteLine($"\n[FAIL ciclo {ciclo}] Start failed: {startResult}");
                    return FailureType.StartFailed;
                }

                var captureResult = EngineResult.InvalidState;
                var t = new Thread(() =>
                {
                    captureResult = engine.RunCaptureLoop();
                })
                {
                    IsBackground = true
                };

                t.Start();

                Thread.Sleep(Random.Shared.Next(0, 5));
                engine.Stop();

                // Espera activa por estado, no por timeout fijo
                SpinWait spin = default;
                while (engine.IsRunning)
                    spin.SpinOnce();

                t.Join(); // ya debería estar fuera

                // Validate capture loop result
                if (captureResult != EngineResult.Success && captureResult != EngineResult.Stopped)
                {
                    Console.WriteLine($"\n[FAIL ciclo {ciclo}] CaptureLoop error: {captureResult}");
                    return FailureType.CaptureLoopFailed;
                }

                return FailureType.None;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\n[EXCEPTION ciclo {ciclo}] {ex.GetType().Name}: {ex.Message}");
                Console.WriteLine($"  Stack: {ex.StackTrace?.Split('\n').FirstOrDefault()?.Trim()}");
                return FailureType.Exception;
            }
        }

        private static async Task WarmupAsync()
        {
            Console.Write("Calentando... ");
            await Task.Run(() => SendTrafficMixed(WarmupPackets, PerformancePort));
            Thread.Sleep(200);
            Console.WriteLine("OK");
        }

        private static void PrepareGcForMeasurement()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
        }

        private static async Task RunMeasurementTrafficAsync()
        {
            Console.WriteLine($"Enviando {MeasurementPackets:N0} paquetes mixtos...");
            await Task.Run(() => SendTrafficMixed(MeasurementPackets, PerformancePort));
        }

        private static void RunBursts()
        {
            Console.WriteLine("Enviando ráfagas (bursts)...");
            for (int i = 0; i < BurstCount; i++)
            {
                SendTrafficBurst(BurstSize, PerformancePort);
                Thread.Sleep(10);
            }
        }

        private static void PrintPerformanceSummary(long packetCount, long memStart, long memEnd, int g0Start, int g0End, long tStart, long tEnd)
        {
            long memDelta = memEnd - memStart;
            int gcTriggers = g0End - g0Start;
            double seconds = Stopwatch.GetElapsedTime(tStart, tEnd).TotalSeconds - 0.5;
            if (seconds < 0.1) seconds = 0.1;
            long pps = (long)(packetCount / seconds);

            Console.WriteLine("────────────────────────────────");
            Console.WriteLine("RESULTADOS NIVEL 3:");
            Console.WriteLine($"PPS: {pps:N0}");
            Console.WriteLine($"GC Gen0: {gcTriggers}");
            Console.WriteLine($"Memoria Delta: {memDelta / 1024.0:F2} KB");
            Console.WriteLine($"Paquetes procesados: {packetCount:N0}");

            if (gcTriggers == 0) Console.WriteLine("✅ ZERO ALLOC CONFIRMADO (Nivel 3)");
            else Console.WriteLine("❌ Asignaciones detectadas");
        }

        private static void SendTrafficMixed(int count, int port)
        {
            using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket.Connect(IPAddress.Loopback, port);

            byte[] small = new byte[64];
            byte[] medium = new byte[512];
            byte[] large = new byte[1400];
            for (int i = 0; i < count; i++)
            {
                int pick = i % 3;
                if (pick == 0) socket.Send(small);
                else if (pick == 1) socket.Send(medium);
                else socket.Send(large);

                if ((i & 1023) == 0) Thread.Yield();
            }
        }

        private static void SendTrafficBurst(int count, int port)
        {
            using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket.Connect(IPAddress.Loopback, port);
            byte[] data = new byte[1400];
            for (int i = 0; i < count; i++) socket.Send(data);
        }
    }
}
]]>
</file>
<file path="NetShaper.StressTest\TestServiceFactory.cs">
<![CDATA[
// NetShaper.StressTest/TestServiceFactory.cs
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;

namespace NetShaper.StressTest
{
    /// <summary>
    /// Factory for creating test services using dependency injection.
    /// Provides a centralized way to create properly configured instances for testing.
    /// </summary>
    internal static class TestServiceFactory
    {
        /// <summary>
        /// Creates a new IEngine instance with all required dependencies.
        /// </summary>
        /// <returns>A configured engine instance.</returns>
        public static IEngine CreateEngine()
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            return provider.GetRequiredService<IEngine>();
        }

        /// <summary>
        /// Creates a new IPacketCapture instance.
        /// </summary>
        /// <returns>A configured packet capture adapter.</returns>
        public static IPacketCapture CreatePacketCapture()
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            return provider.GetRequiredService<IPacketCapture>();
        }

        /// <summary>
        /// Creates a new IPacketLogger instance.
        /// </summary>
        /// <returns>A configured packet logger.</returns>
        public static IPacketLogger CreatePacketLogger()
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            return provider.GetRequiredService<IPacketLogger>();
        }

        /// <summary>
        /// Creates a new IEngine instance with custom logger and capture adapter.
        /// </summary>
        /// <param name="logger">The packet logger to use.</param>
        /// <param name="capture">The packet capture adapter to use.</param>
        /// <returns>A configured engine instance.</returns>
        public static IEngine CreateEngine(IPacketLogger logger, IPacketCapture capture)
        {
            // For custom instances, create Engine with single thread
            Func<IPacketCapture> captureFactory = () => capture;
            return new Engine.Engine(logger, captureFactory, threadCount: 1);
        }

        /// <summary>
        /// Creates a new Engine instance with N threads using batch mode.
        /// </summary>
        public static Engine.Engine CreateEngine(int threadCount = 4)
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            var logger = provider.GetRequiredService<IPacketLogger>();
            
            // Factory uses interface instead of concrete type
            Func<IPacketCapture> captureFactory = () => 
                new NetShaper.Native.WinDivertAdapter();
            
            return new Engine.Engine(logger, captureFactory, threadCount);
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Bootstrap.cs">
<![CDATA[
// NetShaper.UI/Bootstrap.cs
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;
using NetShaper.UI.Controllers;
using NetShaper.UI.Views;

namespace NetShaper.UI
{
    /// <summary>
    /// Composition root for the NetShaper UI application.
    /// Configures dependency injection and builds the service provider.
    /// </summary>
    static class Bootstrap
    {
        /// <summary>
        /// Builds and configures the application controller with all dependencies.
        /// </summary>
        /// <returns>Configured application controller instance.</returns>
        public static IApplicationController BuildController()
        {
            var services = new ServiceCollection();
            
            // Register core NetShaper services (logger, capture, engine)
            services.AddNetShaperServices();
            
            // Register UI-specific services
            services.AddSingleton<IConsoleView, ConsoleStatsView>();
            services.AddSingleton<IApplicationController, ConsoleApplicationController>();
            
            var serviceProvider = services.BuildServiceProvider();
            
            // Resolve the application controller from the container
            return serviceProvider.GetRequiredService<IApplicationController>();
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Program.cs">
<![CDATA[
// NetShaper.App/Program.cs
using System;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.UI;

namespace NetShaper.UI
{
    sealed class Program
    {
        static async Task<int> Main(string[] args)
        {
            using CancellationTokenSource cts = new CancellationTokenSource();

            Console.CancelKeyPress += (_, e) =>
            {
                e.Cancel = true;
                cts.Cancel();
            };

            try
            {
                var controller = Bootstrap.BuildController();
                return await controller.RunAsync(cts.Token);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CRITICAL] {ex.GetType().Name}: {ex.Message}");
                return 1;
            }
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Controllers\ConsoleApplicationController.cs">
<![CDATA[
using System;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Abstractions;
using NetShaper.UI.Views;

namespace NetShaper.UI.Controllers
{
    sealed class ConsoleApplicationController : IApplicationController
    {
        private readonly EngineController _controller;

        public ConsoleApplicationController(IEngine engine, IPacketLogger logger, IConsoleView consoleView)
        {
            ArgumentNullException.ThrowIfNull(engine);
            ArgumentNullException.ThrowIfNull(logger);
            ArgumentNullException.ThrowIfNull(consoleView);

            _controller = new EngineController(engine, logger, consoleView);
        }

        public async Task<int> RunAsync(CancellationToken ct)
        {
            while (!ct.IsCancellationRequested)
            {
                if (_controller.IsRunning)
                {
                    // RUNNING STATE: Show stats, wait for ESC
                    await RunningStateAsync(ct);
                }
                else
                {
                    // MENU STATE: Show menu, process commands
                    var exitCode = await MenuStateAsync(ct);
                    if (exitCode.HasValue)
                        return exitCode.Value;
                }
            }

            return 0;
        }

        private async Task<int?> MenuStateAsync(CancellationToken ct)
        {
            DrawMenu();
            
            var key = Console.ReadKey(true).KeyChar;

            switch (key)
            {
                case '1':
                    HandleStart(ct);
                    return null; // Continue to running state
                    
                case '3':
                    return await HandleExitAsync(ct);
                    
                default:
                    return null; // Ignore invalid input, redraw menu
            }
        }

        private async Task RunningStateAsync(CancellationToken ct)
        {
            Console.Clear();
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine("   NetShaper - Capturando Paquetes");
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine();
            Console.WriteLine("Presiona ESC para detener y volver al menú");
            Console.WriteLine();
            Console.WriteLine("Estadísticas:");
            Console.WriteLine();

            // Wait for ESC while engine is running
            while (_controller.IsRunning && !ct.IsCancellationRequested)
            {
                if (Console.KeyAvailable)
                {
                    var key = Console.ReadKey(true).Key;
                    if (key == ConsoleKey.Escape)
                    {
                        HandleStop();
                        await Task.Delay(300); // Wait for clean shutdown
                        break;
                    }
                }
                
                await Task.Delay(50);
            }
        }

        private void HandleStart(CancellationToken ct)
        {
            StartResult result = _controller.Start("ip and (tcp or udp)", ct);
            
            if (result != StartResult.Success)
            {
                Console.Clear();
                Console.WriteLine("════════════════════════════════════════");
                Console.WriteLine("   Error al Iniciar");
                Console.WriteLine("════════════════════════════════════════");
                Console.WriteLine();
                Console.WriteLine($"❌ Error: {result}");
                Console.WriteLine();
                
                if (result == StartResult.OpenFailed)
                {
                    Console.WriteLine("Posibles causas:");
                    Console.WriteLine("- NO tienes privilegios de ADMINISTRADOR");
                    Console.WriteLine("- El driver WinDivert no está instalado");
                }
                else if (result == StartResult.InvalidFilter)
                {
                    Console.WriteLine("El filtro WinDivert es inválido");
                }
                
                Console.WriteLine();
                Console.WriteLine("Presiona cualquier tecla para volver al menú...");
                Console.ReadKey(true);
            }
            // If success, RunAsync will transition to RunningState automatically
        }

        private void HandleStop()
        {
            _controller.Stop();
        }

        private async Task<int> HandleExitAsync(CancellationToken ct)
        {
            await _controller.ShutdownAsync();
            return 0;
        }

        private static void DrawMenu()
        {
            Console.Clear();
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine("   NetShaper - Packet Shaping Monitor");
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine();
            Console.WriteLine("⚠️  IMPORTANTE: Debe ejecutarse como ADMINISTRADOR");
            Console.WriteLine();
            Console.WriteLine("1. Start  - Iniciar captura de paquetes");
            Console.WriteLine("3. Exit   - Salir del programa");
            Console.WriteLine();
            Console.WriteLine("Filtro: ip and (tcp or udp)");
            Console.WriteLine();
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Controllers\EngineController.cs">
<![CDATA[
// NetShaper.UI/Controllers/EngineController.cs
using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Abstractions;
using NetShaper.UI.Views;

namespace NetShaper.UI.Controllers
{
    public sealed class EngineController : IDisposable
    {
        private readonly IEngine _engine;
        private readonly IPacketLogger _logger;
        private readonly IConsoleView _consoleView;

        private CancellationTokenSource? _linkedCts;
        private Task? _captureTask;
        private Task? _monitorTask;
        private int _running;

        private const int ConsoleUpdateInterval = 1000; // Milisegundos entre actualizaciones

        public EngineController(IEngine engine, IPacketLogger logger, IConsoleView consoleView)
        {
            ArgumentNullException.ThrowIfNull(engine);
            ArgumentNullException.ThrowIfNull(logger);
            ArgumentNullException.ThrowIfNull(consoleView);
            
            _engine = engine;
            _logger = logger;
            _consoleView = consoleView;
            _running = 0;
        }

        public bool IsRunning => _engine.IsRunning;
        public long PacketCount => _engine.PacketCount;

        public StartResult Start(string filter, CancellationToken appToken)
        {
            if (Interlocked.CompareExchange(ref _running, 1, 0) != 0)
                return StartResult.AlreadyRunning;

            _linkedCts = CancellationTokenSource.CreateLinkedTokenSource(appToken);

            StartResult result = _engine.Start(filter, _linkedCts.Token);
            if (result != StartResult.Success)
            {
                CleanupRunningFlag();
                return result;
            }

            _captureTask = Task.Run(() =>
            {
                try
                {
                    _engine.RunCaptureLoop();
                }
                finally
                {
                    _linkedCts.Cancel(); // fuerza salida del monitor
                    CleanupRunningFlag();
                }
            }, _linkedCts.Token);

            _monitorTask = StartMonitorTask(_linkedCts.Token);
            return StartResult.Success;
        }

        public void Stop()
        {
            if (Interlocked.CompareExchange(ref _running, 0, 1) != 1)
                return;

            _engine.Stop();
            _linkedCts?.Cancel();
        }

        public async Task ShutdownAsync()
        {
            Stop();

            try
            {
                if (_captureTask != null)
                    await _captureTask.ConfigureAwait(false);

                if (_monitorTask != null)
                    await _monitorTask.ConfigureAwait(false);
            }
            finally
            {
                _linkedCts?.Dispose();
                (_engine as IDisposable)?.Dispose();
            }
        }

        private Task StartMonitorTask(CancellationToken ct)
    {
        return Task.Run(async () =>
        {
            long last = _engine.PacketCount;

            while (!ct.IsCancellationRequested)
            {
                try
                {
                    await Task.Delay(1000, ct).ConfigureAwait(false);

                    long current = _engine.PacketCount;
                    long delta = current - last;

                    _logger.Log(new PacketLogEntry(
                        Stopwatch.GetTimestamp(),
                        LogLevel.Info,
                        LogCode.PacketProcessed,
                        delta));

                    // Only update console if not cancelled
                    if (!ct.IsCancellationRequested)
                    {
                        _consoleView.UpdateStats(delta, current);
                    }

                    last = current;
                }
                catch (TaskCanceledException)
                {
                    // Expected when stopping
                    break;
                }
            }
        }, ct);
    }

        private void CleanupRunningFlag()
        {
            Interlocked.Exchange(ref _running, 0);
        }

        public void Dispose()
        {
            _linkedCts?.Dispose();
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Views\ConsoleStatsView.cs">
<![CDATA[
// NetShaper.UI/Views/ConsoleStatsView.cs
using System;

namespace NetShaper.UI.Views
{
    /// <summary>
    /// Console implementation of statistics view.
    /// Handles direct console manipulation (cursor positioning, formatting).
    /// </summary>
    public sealed class ConsoleStatsView : IConsoleView
    {
        private readonly int _displayLine;
        private long _lastTotal = 0;

        public ConsoleStatsView()
        {
            _displayLine = Console.CursorTop;
            Console.WriteLine(); // Reserve line for stats
        }

        public void UpdateStats(long packetsPerSecond, long totalPackets)
        {
            Console.SetCursorPosition(0, _displayLine);
            
            // Visual indicator if capturing
            string status = totalPackets > _lastTotal ? "🟢" : (totalPackets > 0 ? "⏸️" : "⚪");
            
            Console.Write(
                $"{status} PPS: {packetsPerSecond,10:N0} | Total paquetes: {totalPackets,12:N0}   ");
            
            _lastTotal = totalPackets;
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Views\IConsoleView.cs">
<![CDATA[
// NetShaper.UI/Views/IConsoleView.cs
namespace NetShaper.UI.Views
{
    /// <summary>
    /// Interface for console UI rendering.
    /// Separates presentation logic from business logic (SRP).
    /// </summary>
    public interface IConsoleView
    {
        /// <summary>
        /// Updates the statistics display in the console.
        /// </summary>
        /// <param name="packetsPerSecond">Current packets processed per second.</param>
        /// <param name="totalPackets">Total packets processed.</param>
        void UpdateStats(long packetsPerSecond, long totalPackets);
    }
}
]]>
</file>
</codebase>