

# CONTEXTO: 30 ARCHIVOS - CÓDIGO FUENTE COMPLETO
- NetShaper.Abstractions\IApplicationController.cs
- NetShaper.Abstractions\IEngine.cs
- NetShaper.Abstractions\IPacketCapture.cs
- NetShaper.Abstractions\IPacketLogger.cs
- NetShaper.Abstractions\PacketCaptureConstants.cs
- NetShaper.Abstractions\PacketLogEntry.cs
- NetShaper.Abstractions\RuleAttributes.cs
- NetShaper.Abstractions\WrapperResult.cs
- NetShaper.Benchmarks\Benchmarks.cs
- NetShaper.Benchmarks\LatencyJitterBenchmark.cs
- NetShaper.Composition\ServiceCollectionExtensions.cs
- NetShaper.Engine\ArrayPoolDiagnostics.cs
- NetShaper.Engine\Engine.cs
- NetShaper.Engine\EngineTelemetry.cs
- NetShaper.Infrastructure\ConsolePacketLogger.cs
- NetShaper.Infrastructure\RingBufferPacketLogger.cs
- NetShaper.Native\NativeMethods.cs
- NetShaper.Native\WinDivertAdapter.cs
- NetShaper.Native\WinDivertAddress.cs
- NetShaper.Native\WinDivertHandle.cs
- NetShaper.StressTest\ChaoticTests.cs
- NetShaper.StressTest\Program.cs
- NetShaper.StressTest\RealTests.cs
- NetShaper.StressTest\TestServiceFactory.cs
- NetShaper.UI\Bootstrap.cs
- NetShaper.UI\Program.cs
- NetShaper.UI\Controllers\ConsoleApplicationController.cs
- NetShaper.UI\Controllers\EngineController.cs
- NetShaper.UI\Views\ConsoleStatsView.cs
- NetShaper.UI\Views\IConsoleView.cs

# CONTENIDO
<codebase>
<file path="NetShaper.Abstractions\IApplicationController.cs">
<![CDATA[
// NetShaper.Abstractions/IApplicationController.cs
using System.Threading;
using System.Threading.Tasks;

namespace NetShaper.Abstractions
{
    public interface IApplicationController
    {
        Task<int> RunAsync(CancellationToken ct);
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\IEngine.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    public interface IEngine : System.IDisposable
    {
        bool IsRunning { get; }
        long PacketCount { get; }

        StartResult Start(string filter, System.Threading.CancellationToken ct = default);
        void Stop();
        EngineResult RunCaptureLoop();
    }

    public enum StartResult
    {
        Success = 0,
        InvalidFilter = 1,
        AlreadyRunning = 2,
        Disposed = 3,
        OpenFailed = 4
    }

    public enum EngineResult
    {
        Success = 0,
        Stopped = 1,
        InvalidState = 2,
        InvalidHandle = 3,
        InvalidParameter = 4,
        Aborted = 5,
        TooManyErrors = 6
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\IPacketCapture.cs">
<![CDATA[
// NetShaper.Abstractions/IPacketCapture.cs
using System;
using System.Runtime.InteropServices;

namespace NetShaper.Abstractions
{
    public interface IPacketCapture : IDisposable
    {
        CaptureResult Open(string filter);
        CaptureResult Receive(Span<byte> buffer, out uint length, ref PacketMetadata metadata);
        CaptureResult Send(ReadOnlySpan<byte> buffer, ref PacketMetadata metadata);
        void Shutdown();
        void CalculateChecksums(Span<byte> buffer, uint length, ref PacketMetadata metadata);
    }

    public enum CaptureResult
    {
        Success = 0,
        InvalidFilter = 1,
        InvalidHandle = 2,
        InvalidParameter = 3,
        OperationAborted = 4,
        ElementNotFound = 5,
        BufferTooSmall = 6,
        Unknown = 99
    }

    /// <summary>
    /// Packet metadata structure.
    /// Layout matches WINDIVERT_ADDRESS (WinDivert 2.2) for zero-copy interop.
    /// StructLayout is acceptable here as it defines a performance-critical contract.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct PacketMetadata
    {
        public long Timestamp;
        public uint InterfaceIndex;
        public uint SubInterfaceIndex;
        public byte Direction;
        public byte Loopback;
        public byte Impostor;
        public byte IpChecksum;
        public byte TcpChecksum;
        public byte UdpChecksum;
        public ushort Reserved1;
        public uint Reserved2;
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\IPacketLogger.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    public interface IPacketLogger
    {
        void Log(in PacketLogEntry entry);
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\PacketCaptureConstants.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    /// <summary>
    /// Constantes compartidas para captura de paquetes y filtros WinDivert.
    /// </summary>
    public static class PacketCaptureConstants
    {
        /// <summary>
        /// Longitud máxima permitida para un filtro WinDivert.
        /// </summary>
        public const int MaxFilterLength = 1024;
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\PacketLogEntry.cs">
<![CDATA[
using System.Runtime.InteropServices;

namespace NetShaper.Abstractions
{
    [StructLayout(LayoutKind.Sequential)]
    public readonly struct PacketLogEntry
    {
        public readonly long Timestamp;
        public readonly LogLevel Level;
        public readonly LogCode Code;
        public readonly long Value;

        public PacketLogEntry(long timestamp, LogLevel level, LogCode code, long value)
        {
            Timestamp = timestamp;
            Level = level;
            Code = code;
            Value = value;
        }
    }

    public enum LogLevel : byte
    {
        Info = 0,
        Warning = 1,
        Error = 2
    }

    public enum LogCode : ushort
    {
        None = 0,
        EngineStarted = 1,
        EngineStopped = 2,
        PacketProcessed = 3,
        RecvFailed = 4,
        SendFailed = 5,
        InvalidPacket = 6,
        OperationAborted = 7,
        InvalidHandle = 8,
        InvalidParameter = 9
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\RuleAttributes.cs">
<![CDATA[
// NetShaper.Abstractions/RuleAttributes.cs
using System;

namespace NetShaper.Abstractions
{
    /// <summary>
    /// Marks methods that are allowed to use async/Task in Engine namespace.
    /// These are typically initialization or configuration methods that run outside the hot path.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class EngineSetupAttribute : Attribute { }

    /// <summary>
    /// Marks methods or classes that are application boundaries.
    /// These are allowed to catch generic Exception types.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]
    public sealed class BoundaryAttribute : Attribute { }

    /// <summary>
    /// Marks a class as the composition root for dependency injection.
    /// Each assembly should have at most one composition root.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class CompositionRootAttribute : Attribute { }

    /// <summary>
    /// Provides justification for rule violations that are acceptable.
    /// Used to document why a constructor exceeds normal dependency limits, etc.
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Constructor)]
    public sealed class JustificationAttribute : Attribute 
    {
        public string Reason { get; }
        
        /// <summary>
        /// Creates a justification attribute with the specified reason.
        /// </summary>
        /// <param name="reason">The reason this violation is acceptable.</param>
        public JustificationAttribute(string reason) => Reason = reason;
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\WrapperResult.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    public enum WrapperResult
    {
        Success = 0,
        InvalidFilter = 1,
        InvalidHandle = 2,
        InvalidParameter = 3,
        OperationAborted = 4,
        ElementNotFound = 5,
        BufferTooSmall = 6,
        Unknown = 99
    }
}
]]>
</file>
<file path="NetShaper.Benchmarks\Benchmarks.cs">
<![CDATA[
// NetShaper.Benchmarks/Benchmarks.cs
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;
using NetShaper.Engine;

namespace NetShaper.Benchmarks
{
    internal static class Program
    {
        private static void Main(string[] args)
        {
            // Run both throughput and latency/jitter benchmarks
            var summary = BenchmarkRunner.Run(typeof(Program).Assembly);
        }
    }

    [MemoryDiagnoser]
    [ThreadingDiagnoser]
    public class EngineBenchmarks
    {
        private const int Port = 55556;
        private const int PacketCount = 10000;

        private Engine.Engine _engine = null!;
        private CancellationTokenSource _cts = null!;
        private Task _captureTask = null!;
        private Socket _socket = null!;
        private IPacketLogger _logger = null!;
        private IPacketCapture _capture = null!;

        private byte[] _small = null!;
        private byte[] _medium = null!;
        private byte[] _large = null!;

        [GlobalSetup]
        public void Setup()
        {
            _small = new byte[64];
            _medium = new byte[512];
            _large = new byte[1400];

            _socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            _socket.Connect(IPAddress.Loopback, Port);

            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();

            _logger = provider.GetRequiredService<IPacketLogger>();
            _capture = provider.GetRequiredService<IPacketCapture>();

            _engine = new Engine.Engine(_logger, _capture);
            _cts = new CancellationTokenSource();

            var result = _engine.Start($"outbound and udp.DstPort == {Port}", _cts.Token);
            if (result != StartResult.Success)
                throw new InvalidOperationException(result.ToString());

            _captureTask = Task.Factory.StartNew(
                static state =>
                {
                    var engine = (Engine.Engine)state!;
                    engine.RunCaptureLoop();
                },
                _engine,
                TaskCreationOptions.LongRunning);

            Thread.Sleep(200);
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _engine.Stop();
            _cts.Cancel();

            try { _captureTask.Wait(1000); } catch { }

            _engine.Dispose();
            _cts.Dispose();
            _socket.Dispose();
            _capture.Dispose();
        }

        [Benchmark(Description = "10k packets - 64 bytes")]
        public void SmallPackets()
        {
            for (int i = 0; i < PacketCount; i++)
            {
                _socket.Send(_small);
                if ((i & 255) == 0) Thread.Yield();
            }
        }

        [Benchmark(Description = "10k packets - 512 bytes")]
        public void MediumPackets()
        {
            for (int i = 0; i < PacketCount; i++)
            {
                _socket.Send(_medium);
                if ((i & 255) == 0) Thread.Yield();
            }
        }

        [Benchmark(Description = "10k packets - 1400 bytes")]
        public void LargePackets()
        {
            for (int i = 0; i < PacketCount; i++)
            {
                _socket.Send(_large);
                if ((i & 255) == 0) Thread.Yield();
            }
        }
    }
}
]]>
</file>
<file path="NetShaper.Benchmarks\LatencyJitterBenchmark.cs">
<![CDATA[
// NetShaper.Benchmarks/LatencyJitterBenchmark.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;

namespace NetShaper.Benchmarks
{
    /// <summary>
    /// Benchmark de latencia individual y jitter.
    /// Optimizado para hardware lento - expectativas realistas.
    /// </summary>
    [MemoryDiagnoser]
    [SimpleJob(warmupCount: 1, iterationCount: 3)]
    public class LatencyJitterBenchmark
    {
        private const int Port = 55558;
        private const int SampleCount = 500; // Reducido para hardware lento
        
        private IEngine _engine = null!;
        private CancellationTokenSource _cts = null!;
        private Task _captureTask = null!;
        private Socket _socket = null!;
        private byte[] _packet = null!;

        [GlobalSetup]
        public void Setup()
        {
            _packet = new byte[512];
            _socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            _socket.Connect(IPAddress.Loopback, Port);

            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();

            _engine = provider.GetRequiredService<IEngine>();
            _cts = new CancellationTokenSource();

            var result = _engine.Start($"outbound and udp.DstPort == {Port}", _cts.Token);
            if (result != StartResult.Success)
                throw new InvalidOperationException($"Start failed: {result}");

            _captureTask = Task.Run(() => _engine.RunCaptureLoop(), _cts.Token);

            // Warmup ligero
            for (int i = 0; i < 100; i++)
            {
                _socket.Send(_packet);
                Thread.Sleep(5); // Delay para no saturar
            }

            Thread.Sleep(500);
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _engine.Stop();
            _cts.Cancel();
            try { _captureTask.Wait(2000); } catch { }
            _engine.Dispose();
            _cts.Dispose();
            _socket.Dispose();
        }

        /// <summary>
        /// Mide latencia de procesamiento individual (send to processed).
        /// Envía 1 paquete, espera que se procese, mide tiempo total.
        /// </summary>
        [Benchmark(Description = "Individual Latency (500 samples)")]
        public LatencyStats MeasureIndividualLatency()
        {
            var latencies = new List<long>(SampleCount);

            for (int i = 0; i < SampleCount; i++)
            {
                long baseline = _engine.PacketCount;
                long start = Stopwatch.GetTimestamp();

                _socket.Send(_packet);

                // Esperar hasta que el paquete sea procesado
                while (_engine.PacketCount == baseline)
                {
                    Thread.SpinWait(50);
                }

                long end = Stopwatch.GetTimestamp();
                latencies.Add(end - start);

                // Pequeño delay entre mediciones para evitar saturación
                Thread.Sleep(2);
            }

            var result = CalculateLatencyStats(latencies);
            
            // Guardar en Desktop con ruta absoluta
            try
            {
                string resultsPath = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
                    "netshaper_latency_results.txt");
                File.AppendAllText(resultsPath, 
                    $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] LATENCY: {result}\n");
            }
            catch { /* Ignore file errors in benchmark */ }
            
            return result;
        }

        /// <summary>
        /// Mide jitter enviando paquetes a ritmo constante (100 PPS).
        /// </summary>
        [Benchmark(Description = "Jitter at 100 PPS")]
        public JitterStats MeasureJitterAt100Pps()
        {
            var latencies = new List<long>(SampleCount);
            long intervalTicks = Stopwatch.Frequency / 100; // 10ms interval = 100 PPS

            long nextSend = Stopwatch.GetTimestamp();

            for (int i = 0; i < SampleCount; i++)
            {
                long baseline = _engine.PacketCount;
                long start = Stopwatch.GetTimestamp();

                // Esperar hasta el momento exacto de envío
                while (Stopwatch.GetTimestamp() < nextSend)
                    Thread.SpinWait(10);

                _socket.Send(_packet);
                nextSend += intervalTicks;

                // Esperar procesamiento
                while (_engine.PacketCount == baseline)
                {
                    Thread.SpinWait(50);
                }

                long end = Stopwatch.GetTimestamp();
                latencies.Add(end - start);
            }

            var result = CalculateJitterStats(latencies);
            
            // Guardar en Desktop con ruta absoluta
            try
            {
                string resultsPath = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
                    "netshaper_latency_results.txt");
                File.AppendAllText(resultsPath, 
                    $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] JITTER: {result}\n");
            }
            catch { /* Ignore file errors in benchmark */ }
            
            return result;
        }

        private static LatencyStats CalculateLatencyStats(List<long> latencies)
        {
            latencies.Sort();
            double ToMicroseconds(long ticks) => (ticks * 1_000_000.0) / Stopwatch.Frequency;

            return new LatencyStats
            {
                P50_us = ToMicroseconds(latencies[latencies.Count / 2]),
                P95_us = ToMicroseconds(latencies[(int)(latencies.Count * 0.95)]),
                P99_us = ToMicroseconds(latencies[(int)(latencies.Count * 0.99)]),
                Min_us = ToMicroseconds(latencies[0]),
                Max_us = ToMicroseconds(latencies[^1]),
                Mean_us = ToMicroseconds((long)latencies.Average())
            };
        }

        private static JitterStats CalculateJitterStats(List<long> latencies)
        {
            double ToMicroseconds(long ticks) => (ticks * 1_000_000.0) / Stopwatch.Frequency;

            var mean = latencies.Average();
            var variance = latencies.Select(l => Math.Pow(l - mean, 2)).Average();
            var stdDev = Math.Sqrt(variance);

            var deltas = new List<double>();
            for (int i = 1; i < latencies.Count; i++)
            {
                deltas.Add(Math.Abs(latencies[i] - latencies[i - 1]));
            }

            deltas.Sort();

            return new JitterStats
            {
                StdDev_us = ToMicroseconds((long)stdDev),
                MaxJitter_us = ToMicroseconds((long)deltas.Max()),
                AvgJitter_us = ToMicroseconds((long)deltas.Average()),
                P95Jitter_us = ToMicroseconds((long)deltas[(int)(deltas.Count * 0.95)])
            };
        }
    }

    public struct LatencyStats
    {
        public double P50_us;
        public double P95_us;
        public double P99_us;
        public double Min_us;
        public double Max_us;
        public double Mean_us;

        public override string ToString() =>
            $"P50={P50_us:F0}μs P95={P95_us:F0}μs P99={P99_us:F0}μs (Min={Min_us:F0} Max={Max_us:F0})";
    }

    public struct JitterStats
    {
        public double StdDev_us;
        public double MaxJitter_us;
        public double AvgJitter_us;
        public double P95Jitter_us;

        public override string ToString() =>
            $"Avg={AvgJitter_us:F0}μs P95={P95Jitter_us:F0}μs Max={MaxJitter_us:F0}μs (σ={StdDev_us:F0})";
    }
}
]]>
</file>
<file path="NetShaper.Composition\ServiceCollectionExtensions.cs">
<![CDATA[
// NetShaper.Composition/ServiceCollectionExtensions.cs
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Infrastructure;
using NetShaper.Native;

namespace NetShaper.Composition
{
    /// <summary>
    /// Composition root for NetShaper dependency injection.
    /// This is the ONLY place where concrete implementations are wired to abstractions.
    /// </summary>
    [CompositionRoot]
    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// Registers all NetShaper core services including packet capture, logging, and engine.
        /// This method wires all concrete implementations to their abstractions.
        /// </summary>
        /// <param name="services">The service collection to add services to.</param>
        /// <returns>The service collection for chaining.</returns>
        public static IServiceCollection AddNetShaperServices(this IServiceCollection services)
        {
            // Register packet logger as singleton (maintains state across application lifetime)
            services.AddSingleton<IPacketLogger, RingBufferPacketLogger>();
            
            // Register packet capture as transient (new instance per engine)
            services.AddTransient<IPacketCapture, WinDivertAdapter>();
            
            // Register engine as transient (properly resolved from DI)
            services.AddTransient<IEngine, Engine.Engine>();
            
            return services;
        }
    }
}
]]>
</file>
<file path="NetShaper.Engine\ArrayPoolDiagnostics.cs">
<![CDATA[
// NetShaper.Engine/ArrayPoolDiagnostics.cs
using System.Diagnostics;
using System.Threading;

namespace NetShaper.Engine
{
    /// <summary>
    /// Diagnósticos para rastrear el balance de ArrayPool rent/return.
    /// Solo activo en builds DEBUG.
    /// </summary>
    internal static class ArrayPoolDiagnostics
    {
        private static int _rentCount;
        private static int _returnCount;

        public static void RecordRent()
        {
            Interlocked.Increment(ref _rentCount);
        }

        public static void RecordReturn()
        {
            Interlocked.Increment(ref _returnCount);
        }

        [Conditional("DEBUG")]
        public static void ValidateBalance()
        {
            // Simple read with memory barrier - good enough for DEBUG diagnostics
            // Potential race is acceptable since this is only for developer awareness
            int rents = Volatile.Read(ref _rentCount);
            int returns = Volatile.Read(ref _returnCount);
            
            Debug.Assert(rents == returns, 
                $"ArrayPool mismatch: Rent={rents}, Return={returns}");
        }
    }
}
]]>
</file>
<file path="NetShaper.Engine\Engine.cs">
<![CDATA[
// NetShaper.Engine/Engine.cs
using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading;
using NetShaper.Abstractions;

namespace NetShaper.Engine
{
    public sealed class Engine : IEngine
    {
        private const int BufferSize = 2048;
        private const int MaxConsecutiveErrors = 1000;
        private const uint MinPacketSize = 20;
        private const uint MaxIpPacketSize = 65535;

        private const int StateIdle = 0;
        private const int StateRunning = 1;
        private const int StateStopping = 2;
        private const int StateFaulted = 3;
        private const int StateDisposed = 4;

        private readonly EngineTelemetry _telemetry;
        private readonly IPacketLogger _logger;
        private readonly IPacketCapture _capture;
        private readonly byte[] _buffer;

        private int _state;
        private int _cancelRequested;
        private int _captureThreadActive;

        public bool IsRunning => Interlocked.CompareExchange(ref _state, 0, 0) == StateRunning;
        public long PacketCount => _telemetry.PacketsProcessed;

        public Engine(IPacketLogger logger, IPacketCapture capture)
        {
            _telemetry = new EngineTelemetry();
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _capture = capture ?? throw new ArgumentNullException(nameof(capture));

            _buffer = ArrayPool<byte>.Shared.Rent(BufferSize);
            ArrayPoolDiagnostics.RecordRent();

            _state = StateIdle;
            _cancelRequested = 0;
        }

        public StartResult Start(string filter, CancellationToken ct = default)
        {
            int state = Interlocked.CompareExchange(ref _state, 0, 0);
            if (state == StateRunning || state == StateStopping)
                return StartResult.AlreadyRunning;
            if (state == StateDisposed)
                return StartResult.Disposed;
            if (string.IsNullOrWhiteSpace(filter))
                return StartResult.InvalidFilter;

            if (Interlocked.CompareExchange(ref _state, StateRunning, StateIdle) != StateIdle)
                return StartResult.AlreadyRunning;

            Interlocked.Exchange(ref _cancelRequested, 0);

            CaptureResult result = _capture.Open(filter);
            if (result != CaptureResult.Success)
            {
                Interlocked.Exchange(ref _state, StateIdle);
                return result == CaptureResult.InvalidFilter
                    ? StartResult.InvalidFilter
                    : StartResult.OpenFailed;
            }

            _telemetry.Reset();
            Log(LogCode.EngineStarted, 0);
            return StartResult.Success;
        }

        public void Stop()
        {
            if (Interlocked.CompareExchange(ref _state, StateStopping, StateRunning) != StateRunning)
                return;

            Interlocked.Exchange(ref _cancelRequested, 1);
            _capture.Shutdown();
        }

        public EngineResult RunCaptureLoop()
        {
            int currentState = Interlocked.CompareExchange(ref _state, 0, 0);
            
            // If Stop() was called before we entered, return Stopped gracefully
            if (currentState == StateStopping)
                return EngineResult.Stopped;
            
            // Only StateRunning is valid for starting the capture loop
            if (currentState != StateRunning)
                return EngineResult.InvalidState;

            // Ensure only one thread can execute capture loop at a time
            // This protects the shared _buffer from concurrent access
            if (Interlocked.CompareExchange(ref _captureThreadActive, 1, 0) != 0)
                return EngineResult.InvalidState;

            EngineResult result;
            try
            {
                result = ProcessLoop();
            }
            finally
            {
                Interlocked.Exchange(ref _captureThreadActive, 0);
            }

            Interlocked.Exchange(
                ref _state,
                result == EngineResult.Success || result == EngineResult.Stopped
                    ? StateIdle
                    : StateFaulted);

            Log(LogCode.EngineStopped, _telemetry.PacketsProcessed);
            return result;
        }

        private EngineResult ProcessLoop()
        {
            PacketMetadata metadata = default;
            Span<byte> buffer = _buffer.AsSpan(0, BufferSize);

            while (true)
            {
                if (ShouldStop())
                    return EngineResult.Stopped;

                CaptureResult recv = _capture.Receive(buffer, out uint len, ref metadata);

                EngineResult? errorResult = HandleReceiveError(recv);
                if (errorResult.HasValue)
                    return errorResult.Value;

                if (!IsValidPacket(len))
                {
                    _telemetry.RecordInvalidPacket();
                    continue;
                }

                ProcessPacket(buffer, len, ref metadata);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private EngineResult? HandleReceiveError(CaptureResult recv)
        {
            if (recv == CaptureResult.Success)
                return null;

            if (recv == CaptureResult.OperationAborted || recv == CaptureResult.InvalidHandle)
                return EngineResult.Stopped;

            _telemetry.RecordRecvError();
            if (_telemetry.ConsecutiveErrors > MaxConsecutiveErrors)
                return EngineResult.TooManyErrors;

            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool ShouldStop()
        {
            return Interlocked.CompareExchange(ref _state, 0, 0) != StateRunning ||
                   Interlocked.CompareExchange(ref _cancelRequested, 0, 0) == 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsValidPacket(uint length)
        {
            return length >= MinPacketSize &&
                   length <= BufferSize &&
                   length <= MaxIpPacketSize;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ProcessPacket(Span<byte> buffer, uint length, ref PacketMetadata metadata)
        {
            Span<byte> packet = buffer.Slice(0, (int)length);
            _capture.CalculateChecksums(packet, length, ref metadata);

            CaptureResult sendResult = _capture.Send(packet, ref metadata);
            
            if (sendResult == CaptureResult.Success)
            {
                _telemetry.RecordPacket();
            }
            else if (sendResult == CaptureResult.InvalidHandle)
            {
                // Handle was disposed during shutdown - this is expected during rapid stop
                // Don't record as error, just ignore
            }
            else
            {
                _telemetry.RecordSendError();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Log(LogCode code, long value)
        {
            _logger.Log(new PacketLogEntry(
                Stopwatch.GetTimestamp(),
                LogLevel.Info,
                code,
                value));
        }

        public void Dispose()
        {
            if (Interlocked.Exchange(ref _state, StateDisposed) == StateDisposed)
                return;

            _capture.Dispose();

            ArrayPool<byte>.Shared.Return(_buffer);
            ArrayPoolDiagnostics.RecordReturn();
            ArrayPoolDiagnostics.ValidateBalance();
        }
    }
}
]]>
</file>
<file path="NetShaper.Engine\EngineTelemetry.cs">
<![CDATA[
// NetShaper.Engine/EngineTelemetry.cs
using System.Runtime.CompilerServices;
using System.Threading;

namespace NetShaper.Engine
{
    internal sealed class EngineTelemetry
    {
        private long _packetsProcessed;
        private long _recvErrors;
        private long _sendErrors;
        private long _invalidPackets;
        private long _consecutiveErrors;

        // Propiedades con Volatile.Read para lecturas cross-thread seguras
        public long PacketsProcessed => Volatile.Read(ref _packetsProcessed);
        public long RecvErrors => Volatile.Read(ref _recvErrors);
        public long SendErrors => Volatile.Read(ref _sendErrors);
        public long InvalidPackets => Volatile.Read(ref _invalidPackets);
        public long ConsecutiveErrors => Volatile.Read(ref _consecutiveErrors);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordPacket()
        {
            Interlocked.Increment(ref _packetsProcessed);
            Interlocked.Exchange(ref _consecutiveErrors, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordRecvError()
        {
            Interlocked.Increment(ref _recvErrors);
            Interlocked.Increment(ref _consecutiveErrors);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordSendError()
        {
            Interlocked.Increment(ref _sendErrors);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordInvalidPacket()
        {
            Interlocked.Increment(ref _invalidPackets);
        }

        public void Reset()
        {
            Interlocked.Exchange(ref _packetsProcessed, 0);
            Interlocked.Exchange(ref _recvErrors, 0);
            Interlocked.Exchange(ref _sendErrors, 0);
            Interlocked.Exchange(ref _invalidPackets, 0);
            Interlocked.Exchange(ref _consecutiveErrors, 0);
        }
    }
}
]]>
</file>
<file path="NetShaper.Infrastructure\ConsolePacketLogger.cs">
<![CDATA[
using System;
using System.Diagnostics;
using NetShaper.Abstractions;

namespace NetShaper.Infrastructure
{
    public sealed class ConsolePacketLogger : IPacketLogger
    {
        private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;

        public void Log(in PacketLogEntry entry)
        {
            long ticks = (long)(entry.Timestamp * TickFrequency);
            TimeSpan elapsed = new TimeSpan(ticks);

            string levelStr = entry.Level switch
            {
                LogLevel.Info => "INFO",
                LogLevel.Warning => "WARN",
                LogLevel.Error => "ERROR",
                _ => "UNKN"
            };

            string codeStr = entry.Code switch
            {
                LogCode.EngineStarted => "Engine Started",
                LogCode.EngineStopped => "Engine Stopped",
                LogCode.PacketProcessed => "Packet Processed",
                LogCode.RecvFailed => "Recv Failed",
                LogCode.SendFailed => "Send Failed",
                LogCode.InvalidPacket => "Invalid Packet",
                LogCode.OperationAborted => "Operation Aborted",
                LogCode.InvalidHandle => "Invalid Handle",
                LogCode.InvalidParameter => "Invalid Parameter",
                _ => "Unknown"
            };

            Console.WriteLine($"[{elapsed.TotalSeconds:F3}s] [{levelStr}] {codeStr} (Value: {entry.Value})");
        }
    }
}
]]>
</file>
<file path="NetShaper.Infrastructure\RingBufferPacketLogger.cs">
<![CDATA[
using System;
using System.Threading;
using NetShaper.Abstractions;

namespace NetShaper.Infrastructure
{
    public sealed class RingBufferPacketLogger : IPacketLogger
    {
        private readonly PacketLogEntry[] _buffer;
        private readonly int _mask;
        private int _index;

        public RingBufferPacketLogger(int powerOfTwoSize = 4096)
        {
            if (powerOfTwoSize <= 0)
                throw new ArgumentOutOfRangeException(nameof(powerOfTwoSize), powerOfTwoSize, "Size must be positive");

            if ((powerOfTwoSize & (powerOfTwoSize - 1)) != 0)
                throw new ArgumentException($"Size must be a power of two. Provided: {powerOfTwoSize}", nameof(powerOfTwoSize));

            _buffer = new PacketLogEntry[powerOfTwoSize];
            _mask = powerOfTwoSize - 1;
            _index = -1;
        }

        public void Log(in PacketLogEntry entry)
        {
            int i = Interlocked.Increment(ref _index) & _mask;
            _buffer[i] = entry;
        }

        public PacketLogEntry[] Snapshot()
        {
            return (PacketLogEntry[])_buffer.Clone();
        }
    }
}
]]>
</file>
<file path="NetShaper.Native\NativeMethods.cs">
<![CDATA[
// NetShaper.Native\NativeMethods.cs
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace NetShaper.Native
{
    public static partial class NativeMethods
    {
        private const string DllName = "WinDivert.dll";

        public const int LayerNetwork = 0;
        public const int WinDivertShutdownRecv = 1;
        public const int WinDivertShutdownSend = 2;
        public const int WinDivertShutdownBoth = 3;

        [LibraryImport(DllName, EntryPoint = "WinDivertOpen", SetLastError = true, StringMarshalling = StringMarshalling.Utf8)]
        [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })]
        public static partial WinDivertHandle WinDivertOpen(
            string filter,
            int layer,
            short priority,
            long flags);

        [LibraryImport(DllName, EntryPoint = "WinDivertShutdown", SetLastError = true)]
        [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static partial bool WinDivertShutdown(
            WinDivertHandle handle, 
            int mode);
    }
}
]]>
</file>
<file path="NetShaper.Native\WinDivertAdapter.cs">
<![CDATA[
// NetShaper.Native/WinDivertAdapter.cs
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NetShaper.Abstractions;

namespace NetShaper.Native
{
    public sealed partial class WinDivertAdapter : IPacketCapture
    {
        private const int MaxFilterLength = PacketCaptureConstants.MaxFilterLength;
        private const int ShutdownRecv = 1;

        private WinDivertHandle? _handle;
        private int _disposed;

        static WinDivertAdapter()
        {
            ValidateStructLayout();
        }

        public CaptureResult Open(string filter)
        {
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return CaptureResult.InvalidHandle;
            if (string.IsNullOrWhiteSpace(filter))
                return CaptureResult.InvalidFilter;
            if (filter.Length > MaxFilterLength)
                return CaptureResult.InvalidFilter;
            if (_handle != null && !_handle.IsInvalid)
                return CaptureResult.InvalidHandle;

            WinDivertHandle? handle = null;

            try
            {
                handle = WinDivertOpenNative(filter, 0, 0, 0);
                if (handle.IsInvalid)
                {
                    int error = Marshal.GetLastWin32Error();
                    // REMOVED: Console.WriteLine to prevent allocations in hot-path
                    // Error code is already returned via MapError(error) below
                    handle.Dispose();
                    return MapError(error);
                }

                _handle = handle;
                return CaptureResult.Success;
            }
            catch (Exception)
            {
                // REMOVED: Console.WriteLine to prevent allocations in hot-path
                // Exception is re-thrown to caller for proper handling
                handle?.Dispose();
                throw;
            }
        }

        public unsafe CaptureResult Receive(
            Span<byte> buffer,
            out uint length,
            ref PacketMetadata metadata)
        {
            length = 0;
            
            CaptureResult validation = ValidateHandle(out WinDivertHandle? handle);
            if (validation != CaptureResult.Success)
                return validation;
            
            if (buffer.IsEmpty)
                return CaptureResult.BufferTooSmall;

            try
            {
                fixed (byte* pBuf = buffer)
                {
                    WinDivertAddress addr = ToWinDivertAddress(ref metadata);
                    WinDivertAddress* pAddr = &addr;

                    bool success = WinDivertRecvNative(
                        handle,
                        pBuf,
                        (uint)buffer.Length,
                        out length,
                        pAddr);

                    if (!success)
                        return MapError(Marshal.GetLastWin32Error());

                    metadata = FromWinDivertAddress(ref addr);
                    return CaptureResult.Success;
                }
            }
            catch (ObjectDisposedException)
            {
                // Handle was disposed during shutdown between our null check and usage
                // This is expected during rapid stop sequences - treat as InvalidHandle
                return CaptureResult.InvalidHandle;
            }
        }

        public unsafe CaptureResult Send(
            ReadOnlySpan<byte> buffer,
            ref PacketMetadata metadata)
        {
            CaptureResult validation = ValidateHandle(out WinDivertHandle? handle);
            if (validation != CaptureResult.Success)
                return validation;
            
            if (buffer.IsEmpty)
                return CaptureResult.InvalidParameter;

            try
            {
                fixed (byte* pBuf = buffer)
                {
                    WinDivertAddress addr = ToWinDivertAddress(ref metadata);
                    WinDivertAddress* pAddr = &addr;

                    bool success = WinDivertSendNative(
                        handle,
                        pBuf,
                        (uint)buffer.Length,
                        out uint _,
                        pAddr);

                    if (!success)
                        return MapError(Marshal.GetLastWin32Error());

                    return CaptureResult.Success;
                }
            }
            catch (ObjectDisposedException)
            {
                // Handle was disposed during shutdown between our null check and usage
                // This is expected during rapid stop sequences - treat as InvalidHandle
                return CaptureResult.InvalidHandle;
            }
        }

        public void Shutdown()
        {
            // NOTE: Do NOT check _disposed here
            // Shutdown is a temporary pause operation, not final destruction
            // It must work even if the instance will be disposed later
            // This allows proper Start/Stop reentrancy as per rules v2 §71
            
            WinDivertHandle? handle = _handle;
            if (handle == null || handle.IsInvalid)
                return;

            // Shutdown reception first
            WinDivertShutdownNative(handle, ShutdownRecv);
            
            // Close and release the handle to allow restart
            _handle = null;
            handle.Dispose();
        }

        public unsafe void CalculateChecksums(
            Span<byte> buffer,
            uint length,
            ref PacketMetadata metadata)
        {
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return;
            if (buffer.IsEmpty || length == 0)
                return;

            fixed (byte* pBuf = buffer)
            {
                WinDivertAddress addr = ToWinDivertAddress(ref metadata);
                WinDivertAddress* pAddr = &addr;

                WinDivertHelperCalcChecksumsNative(pBuf, length, pAddr, 0);
            }
        }

        public void Dispose()
		{
			if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 0)
			{
				if (_handle != null && !_handle.IsInvalid)
				{
					// Shutdown orderly antes de cerrar handle
					WinDivertShutdownNative(_handle, 0); // 0 = SHUT_RDWR
					_handle.Dispose();
				}
			}
		}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private CaptureResult ValidateHandle(out WinDivertHandle? handle)
        {
            handle = null;
            
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return CaptureResult.InvalidHandle;

            handle = _handle;
            if (handle == null || handle.IsInvalid)
                return CaptureResult.InvalidHandle;

            return CaptureResult.Success;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static CaptureResult MapError(int code)
        {
            return code switch
            {
                995 => CaptureResult.OperationAborted,
                6 => CaptureResult.InvalidHandle,
                87 => CaptureResult.InvalidParameter,
                1168 => CaptureResult.ElementNotFound,
                _ => CaptureResult.Unknown
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static WinDivertAddress ToWinDivertAddress(ref PacketMetadata metadata)
        {
            return new WinDivertAddress
            {
                Timestamp = metadata.Timestamp,
                IfIdx = metadata.InterfaceIndex,
                SubIfIdx = metadata.SubInterfaceIndex,
                Direction = metadata.Direction,
                Loopback = metadata.Loopback,
                Impostor = metadata.Impostor,
                IPChecksum = metadata.IpChecksum,
                TCPChecksum = metadata.TcpChecksum,
                UDPChecksum = metadata.UdpChecksum,
                Reserved1 = metadata.Reserved1,
                Reserved2 = metadata.Reserved2
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static PacketMetadata FromWinDivertAddress(ref WinDivertAddress addr)
        {
            return new PacketMetadata
            {
                Timestamp = addr.Timestamp,
                InterfaceIndex = addr.IfIdx,
                SubInterfaceIndex = addr.SubIfIdx,
                Direction = addr.Direction,
                Loopback = addr.Loopback,
                Impostor = addr.Impostor,
                IpChecksum = addr.IPChecksum,
                TcpChecksum = addr.TCPChecksum,
                UdpChecksum = addr.UDPChecksum,
                Reserved1 = addr.Reserved1,
                Reserved2 = addr.Reserved2
            };
        }

        [Conditional("DEBUG")]
        private static void ValidateStructLayout()
        {
            Debug.Assert(Marshal.SizeOf<WinDivertAddress>() == 28,
                "WinDivertAddress size mismatch - expected 28 bytes");
            Debug.Assert(Marshal.OffsetOf<WinDivertAddress>(nameof(WinDivertAddress.Timestamp)).ToInt32() == 0,
                "WinDivertAddress.Timestamp offset incorrect");
            Debug.Assert(Marshal.OffsetOf<WinDivertAddress>(nameof(WinDivertAddress.IfIdx)).ToInt32() == 8,
                "WinDivertAddress.IfIdx offset incorrect");
        }

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertOpen", StringMarshalling = StringMarshalling.Utf8)]
        private static partial WinDivertHandle WinDivertOpenNative(
            string filter,
            int layer,
            short priority,
            ulong flags);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertRecv")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static unsafe partial bool WinDivertRecvNative(
            WinDivertHandle handle,
            byte* pPacket,
            uint packetLen,
            out uint readLen,
            WinDivertAddress* pAddr);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertSend")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static unsafe partial bool WinDivertSendNative(
            WinDivertHandle handle,
            byte* pPacket,
            uint packetLen,
            out uint writeLen,
            WinDivertAddress* pAddr);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertShutdown")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static partial bool WinDivertShutdownNative(
            WinDivertHandle handle,
            int how);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertHelperCalcChecksums")]
        private static unsafe partial void WinDivertHelperCalcChecksumsNative(
            byte* pPacket,
            uint packetLen,
            WinDivertAddress* pAddr,
            ulong flags);
    }
}
]]>
</file>
<file path="NetShaper.Native\WinDivertAddress.cs">
<![CDATA[
// NetShaper.Native/WinDivertAddress.cs
using System.Runtime.InteropServices;

namespace NetShaper.Native
{
    /// <summary>
    /// Internal WinDivert address structure.
    /// This is an implementation detail specific to WinDivert and should not leak to abstractions.
    /// Layout matches WINDIVERT_ADDRESS (WinDivert 2.2).
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct WinDivertAddress
    {
        public long Timestamp;
        public uint IfIdx;
        public uint SubIfIdx;
        public byte Direction;
        public byte Loopback;
        public byte Impostor;
        public byte IPChecksum;
        public byte TCPChecksum;
        public byte UDPChecksum;
        public ushort Reserved1;
        public uint Reserved2;
    }
}
]]>
</file>
<file path="NetShaper.Native\WinDivertHandle.cs">
<![CDATA[
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;

namespace NetShaper.Native
{
    public sealed partial class WinDivertHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        public WinDivertHandle() : base(true) { }

        protected override bool ReleaseHandle()
        {
            return WinDivertClose(handle);
        }

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertClose", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static partial bool WinDivertClose(IntPtr handle);
    }

    // WinDivertAddress movido a NetShaper.Abstractions
}
]]>
</file>
<file path="NetShaper.StressTest\ChaoticTests.cs">
<![CDATA[
// NetShaper.StressTest/ChaoticTests.cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Abstractions;

namespace NetShaper.StressTest
{
    static class ChaoticTests
    {
        private const int WorkerCount = 64;
        private const int IterationsPerWorker = 500;
        private const int FilterCount = 7;
        private const int MaxRandomDelay = 10;

        private static readonly string[] Filters = new[]
        {
            "ip",
            "tcp",
            "udp",
            "outbound and udp.DstPort == 55555",
            "",
            "this is not a valid filter",
            "ip and (tcp or udp)"
        };

        private static volatile bool _supervisorCancel;
        private static int _totalOperations;
        private static int _crashes;
        private static int _exceptions;
        private static int _workersCompleted;

        public static async Task RunChaoticAssaultAsync()
        {
            Console.WriteLine(">>> INICIANDO TEST CAÓTICO (mal uso extremo) <<<");
            Console.WriteLine($"Workers: {WorkerCount} | Iteraciones por worker: {IterationsPerWorker}");
            Console.WriteLine($"Total operaciones planificadas: {WorkerCount * IterationsPerWorker:N0}");
            Console.WriteLine();

            // Reset counters
            _supervisorCancel = false;
            _totalOperations = 0;
            _crashes = 0;
            _exceptions = 0;
            _workersCompleted = 0;

            var sw = System.Diagnostics.Stopwatch.StartNew();
            var tasks = new List<Task>(WorkerCount);

            for (int i = 0; i < WorkerCount; i++)
            {
                int workerId = i;
                tasks.Add(Task.Run(() => WorkerLoop(workerId)));
            }

            var supervisor = Task.Run(() => SupervisorLoop());
            
            // Show progress
            var progressTask = Task.Run(async () =>
            {
                while (_workersCompleted < WorkerCount)
                {
                    await Task.Delay(500);
                    int progress = (_totalOperations * 100) / Math.Max(WorkerCount * IterationsPerWorker, 1);
                    Console.Write($"\rProgreso: {progress}% ({_totalOperations:N0} ops, {_crashes} crashes, {_exceptions} exc)");
                }
            });

            await Task.WhenAll(tasks);
            await Task.Delay(1000);
            _supervisorCancel = true;
            await supervisor;
            sw.Stop();

            // Clear progress line
            Console.WriteLine("\r" + new string(' ', 100));
            Console.WriteLine();

            // Print summary
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine("RESUMEN TEST CAÓTICO:");
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine($"Tiempo total: {sw.ElapsedMilliseconds:N0} ms");
            Console.WriteLine($"Workers ejecutados: {_workersCompleted} / {WorkerCount}");
            Console.WriteLine($"Operaciones completadas: {_totalOperations:N0} / {WorkerCount * IterationsPerWorker:N0}");
            Console.WriteLine($"Crashes (comportamiento esperado): {_crashes:N0}");
            Console.WriteLine($"Excepciones manejadas: {_exceptions:N0}");
            
            double opsPerSecond = _totalOperations / (sw.ElapsedMilliseconds / 1000.0);
            Console.WriteLine($"Throughput: {opsPerSecond:N0} operaciones/segundo");
            
            double crashRate = (_crashes * 100.0) / Math.Max(_totalOperations, 1);
            Console.WriteLine($"Tasa de crashes: {crashRate:F2}%");

            Console.WriteLine("═══════════════════════════════════════════════════════");
            
            // The chaotic test is expected to have crashes - it's testing abuse scenarios
            bool passed = _workersCompleted == WorkerCount && _totalOperations > 0;
            Console.WriteLine(passed ? "✅ TEST COMPLETADO (sistema sobrevivió al abuso)" : "❌ FALLO CRÍTICO");
            Console.WriteLine("═══════════════════════════════════════════════════════");
        }

        private static void WorkerLoop(int workerId)
        {
            var rnd = new Random(unchecked(Environment.TickCount * 31 + workerId));

            for (int iter = 0; iter < IterationsPerWorker; iter++)
            {
                Interlocked.Increment(ref _totalOperations);
                int action = rnd.Next(0, 6);
                try
                {
                    switch (action)
                    {
                        case 0:
                            using (var engine = CreateEngine())
                            {
                                string filter = Filters[rnd.Next(FilterCount)];
                                TryStart(engine, filter, rnd);
                                if (rnd.NextDouble() < 0.2) TryRunCaptureLoop(engine);
                                if (rnd.NextDouble() < 0.1) TryStart(engine, filter, rnd);
                                TryStop(engine);
                            }
                            break;

                        case 1:
                            var e = CreateEngine();
                            TryStart(e, Filters[rnd.Next(FilterCount)], rnd);
                            // Abuse: No Stop() call, but we still need to dispose to avoid ArrayPool assert
                            try { e.Dispose(); } catch { }
                            Interlocked.Increment(ref _crashes); // No proper cleanup - track as crash
                            break;

                        case 2:
                            var engine2 = CreateEngine();
                            var cts = new CancellationTokenSource();
                            var t = Task.Run(() =>
                            {
                                try { engine2.Start("ip", cts.Token); engine2.RunCaptureLoop(); } catch { }
                            });
                            Thread.Sleep(rnd.Next(0, 5));
                            TryStop(engine2);
                            try { engine2.Dispose(); } catch { }
                            break;

                        case 3:
                            var engine3 = CreateEngine();
                            TryStop(engine3);
                            TryRunCaptureLoop(engine3);
                            try { engine3.Dispose(); } catch { }
                            Interlocked.Increment(ref _crashes); // Abuse: stop/run without start
                            break;

                        case 4:
                            using (var engine4 = CreateEngine())
                            {
                                TryStart(engine4, Filters[rnd.Next(FilterCount)], rnd);
                                TryStop(engine4);
                            }
                            break;

                        case 5:
                            ParallelStartStopBurst(rnd);
                            break;
                    }
                }
                catch
                {
                    Interlocked.Increment(ref _exceptions);
                }
            }
            
            Interlocked.Increment(ref _workersCompleted);
        }

        private static IEngine CreateEngine()
        {
            return TestServiceFactory.CreateEngine();
        }

        private static void TryStart(IEngine engine, string filter, Random rnd)
        {
            try
            {
                using var cts = new CancellationTokenSource();
                if (rnd.NextDouble() < 0.15) cts.Cancel();
                engine.Start(filter, cts.Token);
            }
            catch { }
        }

        private static void TryRunCaptureLoop(IEngine engine)
        {
            try
            {
                var t = new Thread(() =>
                {
                    try { engine.RunCaptureLoop(); } catch { }
                });
                t.IsBackground = true;
                t.Start();
                if (new Random().NextDouble() < 0.3) return;
                t.Join(50);
            }
            catch { }
        }

        private static void TryStop(IEngine engine)
        {
            try { engine.Stop(); } catch { }
        }

        private static void ParallelStartStopBurst(Random rnd)
        {
            int burst = rnd.Next(2, 8);
            var engines = new IEngine[burst];
            for (int i = 0; i < burst; i++) engines[i] = CreateEngine();

            Parallel.ForEach(engines, eng =>
            {
                try
                {
                    TryStart(eng, Filters[rnd.Next(FilterCount)], rnd);
                    if (rnd.NextDouble() < 0.5) TryRunCaptureLoop(eng);
                    TryStop(eng);
                }
                catch { }
                finally { try { eng.Dispose(); } catch { } }
            });
        }

        private static void SupervisorLoop()
        {
            var rnd = new Random();
            while (!_supervisorCancel)
            {
                try
                {
                    if (rnd.NextDouble() < 0.3)
                    {
                        var e = CreateEngine();
                        try { e.Start("ip", CancellationToken.None); } catch { }
                        try { e.Stop(); } catch { }
                        try { e.Dispose(); } catch { }
                    }
                }
                catch { }
                Thread.Sleep(rnd.Next(0, MaxRandomDelay));
            }
        }
    }
}
]]>
</file>
<file path="NetShaper.StressTest\Program.cs">
<![CDATA[
using System;
using System.Threading.Tasks;

namespace NetShaper.StressTest
{
    class Program
    {
        static async Task<int> Main(string[] args)
        {
            // Support command-line arguments for automation
            if (args.Length > 0)
            {
                switch (args[0])
                {
                    case "1":
                        RealTests.RunStabilityReal();
                        return 0;
                    case "2":
                        await RealTests.RunPerformanceRealAsync();
                        return 0;
                    case "3":
                        await ChaoticTests.RunChaoticAssaultAsync();
                        return 0;
                    default:
                        Console.WriteLine($"Invalid argument: {args[0]}");
                        return 1;
                }
            }

            // Interactive menu mode
            while (true)
            {
                Console.Clear();
                Console.WriteLine("=== NETSHAPER STRESS TEST SUITE ===");
                Console.WriteLine("1. Test de Estabilidad Real (uso correcto)");
                Console.WriteLine("2. Test de Rendimiento Real (PPS/Jitter/ZeroAlloc)");
                Console.WriteLine("3. Test Caótico (mal uso extremo)");
                Console.WriteLine("4. Salir");
                Console.Write("\nSelecciona una opción: ");

                var key = Console.ReadKey(true);
                Console.WriteLine();

                switch (key.KeyChar)
                {
                    case '1':
                        RealTests.RunStabilityReal();
                        break;
                    case '2':
                        await RealTests.RunPerformanceRealAsync();
                        break;
                    case '3':
                        await ChaoticTests.RunChaoticAssaultAsync();
                        break;
                    case '4':
                        return 0;
                    default:
                        Console.WriteLine("Opción no válida.");
                        break;
                }

                Console.WriteLine("\nPresiona cualquier tecla para volver al menú...");
                Console.ReadKey();
            }
        }
    }
}
]]>
</file>
<file path="NetShaper.StressTest\RealTests.cs">
<![CDATA[
// NetShaper.StressTest/RealTests.cs
using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Engine;
using NetShaper.Abstractions;

namespace NetShaper.StressTest
{
    static class RealTests
    {
        private const int PerformancePort = 55555;
        private const int WarmupPackets = 200;
        private const int MeasurementPackets = 200_000;
        private const int BurstSize = 5000;
        private const int BurstCount = 10;

        public static void RunStabilityReal()
        {
            Console.WriteLine(">>> INICIANDO TEST DE ESTABILIDAD REAL (uso correcto) <<<");
            int cycles = 10000;
            int totalFallos = 0;
            int startFailures = 0;
            int captureLoopFailures = 0;
            int exceptionFailures = 0;
            var failedCycles = new List<int>();
            
            var sw = Stopwatch.StartNew();
            for (int i = 1; i <= cycles; i++)
            {
                FailureType failure = RunSingleCycle(i);
                
                if (failure != FailureType.None)
                {
                    totalFallos++;
                    failedCycles.Add(i);
                    
                    switch (failure)
                    {
                        case FailureType.StartFailed:
                            startFailures++;
                            break;
                        case FailureType.CaptureLoopFailed:
                            captureLoopFailures++;
                            break;
                        case FailureType.Exception:
                            exceptionFailures++;
                            break;
                    }
                }
                
                if (i % 100 == 0) Console.Write(".");
            }

            sw.Stop();
            Console.WriteLine("\n");
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine("RESUMEN ESTABILIDAD REAL:");
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine($"Tiempo total: {sw.ElapsedMilliseconds} ms");
            Console.WriteLine($"Ciclos ejecutados: {cycles:N0}");
            Console.WriteLine($"Fallos totales: {totalFallos}");
            
            if (totalFallos > 0)
            {
                Console.WriteLine("\nFALLOS POR CATEGORÍA:");
                Console.WriteLine($"  - Start failures:       {startFailures}");
                Console.WriteLine($"  - CaptureLoop failures: {captureLoopFailures}");
                Console.WriteLine($"  - Exceptions:           {exceptionFailures}");
                
                Console.WriteLine($"\nTasa de fallo: {(totalFallos * 100.0 / cycles):F3}%");
                Console.WriteLine($"\nCiclos con fallos: {string.Join(", ", failedCycles.Take(20))}");
                if (failedCycles.Count > 20)
                    Console.WriteLine($"  ... y {failedCycles.Count - 20} más");
            }
            
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine(totalFallos == 0 ? "✅ ESTABLE" : "❌ INESTABLE");
            Console.WriteLine("═══════════════════════════════════════════════════════");
        }
        
        private enum FailureType
        {
            None,
            StartFailed,
            CaptureLoopFailed,
            Exception
        }

        private static FailureType RunSingleCycle(int ciclo)
        {
            try
            {
                using var engine = TestServiceFactory.CreateEngine();
                using var cts = new CancellationTokenSource();

                StartResult startResult = engine.Start("ip", cts.Token);
                if (startResult != StartResult.Success)
                {
                    Console.WriteLine($"\n[FAIL ciclo {ciclo}] Start failed: {startResult}");
                    return FailureType.StartFailed;
                }

                var captureResult = EngineResult.InvalidState;
                var t = new Thread(() =>
                {
                    captureResult = engine.RunCaptureLoop();
                })
                {
                    IsBackground = true
                };

                t.Start();

                Thread.Sleep(Random.Shared.Next(0, 5));
                engine.Stop();

                // Espera activa por estado, no por timeout fijo
                SpinWait spin = default;
                while (engine.IsRunning)
                    spin.SpinOnce();

                t.Join(); // ya debería estar fuera

                // Validate capture loop result
                if (captureResult != EngineResult.Success && captureResult != EngineResult.Stopped)
                {
                    Console.WriteLine($"\n[FAIL ciclo {ciclo}] CaptureLoop error: {captureResult}");
                    return FailureType.CaptureLoopFailed;
                }

                return FailureType.None;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\n[EXCEPTION ciclo {ciclo}] {ex.GetType().Name}: {ex.Message}");
                Console.WriteLine($"  Stack: {ex.StackTrace?.Split('\n').FirstOrDefault()?.Trim()}");
                return FailureType.Exception;
            }
        }


        public static async Task RunPerformanceRealAsync()
        {
            Console.WriteLine(">>> INICIANDO TEST DE RENDIMIENTO REAL (PPS/JITTER/ZeroAlloc) <<<");

            using var engine = TestServiceFactory.CreateEngine();
            using var cts = new CancellationTokenSource();

            StartResult result = engine.Start($"outbound and udp.DstPort == {PerformancePort}", cts.Token);

            if (result != StartResult.Success)
            {
                Console.WriteLine($"[FAIL] No se pudo iniciar el engine: {result}");
                return;
            }

            var captureTask = Task.Factory.StartNew(() =>
            {
                try { engine.RunCaptureLoop(); } catch { }
            }, TaskCreationOptions.LongRunning);

            await WarmupAsync();
            PrepareGcForMeasurement();

            long memStart = GC.GetTotalMemory(true);
            int g0Start = GC.CollectionCount(0);
            long tStart = Stopwatch.GetTimestamp();

            await RunMeasurementTrafficAsync();
            RunBursts();

            Thread.Sleep(500);

            engine.Stop();
            cts.Cancel();
            await captureTask;

            engine.Dispose();

            long tEnd = Stopwatch.GetTimestamp();
            long memEnd = GC.GetTotalMemory(false);
            int g0End = GC.CollectionCount(0);
            PrintPerformanceSummary(engine.PacketCount, memStart, memEnd, g0Start, g0End, tStart, tEnd);
        }

        private static async Task WarmupAsync()
        {
            Console.Write("Calentando... ");
            await Task.Run(() => SendTrafficMixed(WarmupPackets, PerformancePort));
            Thread.Sleep(200);
            Console.WriteLine("OK");
        }

        private static void PrepareGcForMeasurement()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
        }

        private static async Task RunMeasurementTrafficAsync()
        {
            Console.WriteLine($"Enviando {MeasurementPackets:N0} paquetes mixtos...");
            await Task.Run(() => SendTrafficMixed(MeasurementPackets, PerformancePort));
        }

        private static void RunBursts()
        {
            Console.WriteLine("Enviando ráfagas (bursts)...");
            for (int i = 0; i < BurstCount; i++)
            {
                SendTrafficBurst(BurstSize, PerformancePort);
                Thread.Sleep(10);
            }
        }

        private static void PrintPerformanceSummary(long packetCount, long memStart, long memEnd, int g0Start, int g0End, long tStart, long tEnd)
        {
            long memDelta = memEnd - memStart;
            int gcTriggers = g0End - g0Start;
            double seconds = Stopwatch.GetElapsedTime(tStart, tEnd).TotalSeconds - 0.5;
            if (seconds < 0.1) seconds = 0.1;
            long pps = (long)(packetCount / seconds);

            Console.WriteLine("────────────────────────────────");
            Console.WriteLine("RESULTADOS NIVEL 3:");
            Console.WriteLine($"PPS: {pps:N0}");
            Console.WriteLine($"GC Gen0: {gcTriggers}");
            Console.WriteLine($"Memoria Delta: {memDelta / 1024.0:F2} KB");
            Console.WriteLine($"Paquetes procesados: {packetCount:N0}");

            if (gcTriggers == 0) Console.WriteLine("✅ ZERO ALLOC CONFIRMADO (Nivel 3)");
            else Console.WriteLine("❌ Asignaciones detectadas");
        }

        private static void SendTrafficMixed(int count, int port)
        {
            using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket.Connect(IPAddress.Loopback, port);

            byte[] small = new byte[64];
            byte[] medium = new byte[512];
            byte[] large = new byte[1400];
            for (int i = 0; i < count; i++)
            {
                int pick = i % 3;
                if (pick == 0) socket.Send(small);
                else if (pick == 1) socket.Send(medium);
                else socket.Send(large);

                if ((i & 1023) == 0) Thread.Yield();
            }
        }

        private static void SendTrafficBurst(int count, int port)
        {
            using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket.Connect(IPAddress.Loopback, port);
            byte[] data = new byte[1400];
            for (int i = 0; i < count; i++) socket.Send(data);
        }
    }
}
]]>
</file>
<file path="NetShaper.StressTest\TestServiceFactory.cs">
<![CDATA[
// NetShaper.StressTest/TestServiceFactory.cs
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;

namespace NetShaper.StressTest
{
    /// <summary>
    /// Factory for creating test services using dependency injection.
    /// Provides a centralized way to create properly configured instances for testing.
    /// </summary>
    internal static class TestServiceFactory
    {
        /// <summary>
        /// Creates a new IEngine instance with all required dependencies.
        /// </summary>
        /// <returns>A configured engine instance.</returns>
        public static IEngine CreateEngine()
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            return provider.GetRequiredService<IEngine>();
        }

        /// <summary>
        /// Creates a new IPacketCapture instance.
        /// </summary>
        /// <returns>A configured packet capture adapter.</returns>
        public static IPacketCapture CreatePacketCapture()
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            return provider.GetRequiredService<IPacketCapture>();
        }

        /// <summary>
        /// Creates a new IPacketLogger instance.
        /// </summary>
        /// <returns>A configured packet logger.</returns>
        public static IPacketLogger CreatePacketLogger()
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            return provider.GetRequiredService<IPacketLogger>();
        }

        /// <summary>
        /// Creates a new IEngine instance with custom logger and capture adapter.
        /// </summary>
        /// <param name="logger">The packet logger to use.</param>
        /// <param name="capture">The packet capture adapter to use.</param>
        /// <returns>A configured engine instance.</returns>
        public static IEngine CreateEngine(IPacketLogger logger, IPacketCapture capture)
        {
            // For custom instances, we need to create the engine directly
            // since we're providing specific instances rather than using DI
            return new Engine.Engine(logger, capture);
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Bootstrap.cs">
<![CDATA[
// NetShaper.UI/Bootstrap.cs
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;
using NetShaper.UI.Controllers;
using NetShaper.UI.Views;

namespace NetShaper.UI
{
    /// <summary>
    /// Composition root for the NetShaper UI application.
    /// Configures dependency injection and builds the service provider.
    /// </summary>
    static class Bootstrap
    {
        /// <summary>
        /// Builds and configures the application controller with all dependencies.
        /// </summary>
        /// <returns>Configured application controller instance.</returns>
        public static IApplicationController BuildController()
        {
            var services = new ServiceCollection();
            
            // Register core NetShaper services (logger, capture, engine)
            services.AddNetShaperServices();
            
            // Register UI-specific services
            services.AddSingleton<IConsoleView, ConsoleStatsView>();
            services.AddSingleton<IApplicationController, ConsoleApplicationController>();
            
            var serviceProvider = services.BuildServiceProvider();
            
            // Resolve the application controller from the container
            return serviceProvider.GetRequiredService<IApplicationController>();
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Program.cs">
<![CDATA[
// NetShaper.App/Program.cs
using System;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.UI;

namespace NetShaper.UI
{
    sealed class Program
    {
        static async Task<int> Main(string[] args)
        {
            using CancellationTokenSource cts = new CancellationTokenSource();

            Console.CancelKeyPress += (_, e) =>
            {
                e.Cancel = true;
                cts.Cancel();
            };

            try
            {
                var controller = Bootstrap.BuildController();
                return await controller.RunAsync(cts.Token);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CRITICAL] {ex.GetType().Name}: {ex.Message}");
                return 1;
            }
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Controllers\ConsoleApplicationController.cs">
<![CDATA[
using System;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Abstractions;
using NetShaper.UI.Views;

namespace NetShaper.UI.Controllers
{
    sealed class ConsoleApplicationController : IApplicationController
    {
        private readonly EngineController _controller;

        public ConsoleApplicationController(IEngine engine, IPacketLogger logger, IConsoleView consoleView)
        {
            ArgumentNullException.ThrowIfNull(engine);
            ArgumentNullException.ThrowIfNull(logger);
            ArgumentNullException.ThrowIfNull(consoleView);

            _controller = new EngineController(engine, logger, consoleView);
        }

        public async Task<int> RunAsync(CancellationToken ct)
        {
            while (!ct.IsCancellationRequested)
            {
                DrawMenu();
                char key = Console.ReadKey(true).KeyChar;

                switch (key)
                {
                    case '1':
                        HandleStart(ct);
                        break;

                    case '2':
                        HandleStop();
                        break;

                    case '3':
                        return await HandleExitAsync(ct);
                }
            }

            return 0;
        }

        private void HandleStart(CancellationToken ct)
        {
            // La UI no toca el Engine directamente.
            // Solo delega al EngineController.
            StartResult result = _controller.Start("ip and (tcp or udp)", ct);
            
            // Si falla, mostrar error y esperar
            if (result != StartResult.Success)
            {
                Console.WriteLine($"\n❌ Error al iniciar el engine: {result}");
                Console.WriteLine("\nPosibles causas:");
                if (result == StartResult.OpenFailed)
                {
                    Console.WriteLine("- NO tienes privilegios de ADMINISTRADOR (WinDivert requiere admin)");
                    Console.WriteLine("- El driver WinDivert no está instalado");
                }
                else if (result == StartResult.InvalidFilter)
                {
                    Console.WriteLine("- El filtro WinDivert es inválido");
                }
                Console.WriteLine("\nPresiona cualquier tecla para continuar...");
                Console.ReadKey(true);
            }
            else
            {
                Console.WriteLine("\n✅ Engine iniciado correctamente");
                Console.WriteLine("El motor está capturando y mostrando estadísticas en tiempo real.");
                Console.WriteLine("Usa la opción '2. Stop' para detener la captura.");
                Console.WriteLine("\nPresiona cualquier tecla para continuar...");
                Console.ReadKey(true);
            }
        }

        private void HandleStop()
        {
            _controller.Stop();
        }

        private async Task<int> HandleExitAsync(CancellationToken ct)
        {
            await _controller.ShutdownAsync();
            return 0;
        }

        private static void DrawMenu()
        {
            Console.Clear();
            Console.WriteLine("NetShaper");
            Console.WriteLine("1. Start");
            Console.WriteLine("2. Stop");
            Console.WriteLine("3. Exit");
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Controllers\EngineController.cs">
<![CDATA[
// NetShaper.UI/Controllers/EngineController.cs
using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Abstractions;
using NetShaper.UI.Views;

namespace NetShaper.UI.Controllers
{
    public sealed class EngineController : IDisposable
    {
        private readonly IEngine _engine;
        private readonly IPacketLogger _logger;
        private readonly IConsoleView _consoleView;

        private CancellationTokenSource? _linkedCts;
        private Task? _captureTask;
        private Task? _monitorTask;
        private int _running;

        private const int ConsoleUpdateInterval = 1000; // Milisegundos entre actualizaciones

        public EngineController(IEngine engine, IPacketLogger logger, IConsoleView consoleView)
        {
            ArgumentNullException.ThrowIfNull(engine);
            ArgumentNullException.ThrowIfNull(logger);
            ArgumentNullException.ThrowIfNull(consoleView);
            
            _engine = engine;
            _logger = logger;
            _consoleView = consoleView;
            _running = 0;
        }

        public bool IsRunning => _engine.IsRunning;
        public long PacketCount => _engine.PacketCount;

        public StartResult Start(string filter, CancellationToken appToken)
        {
            if (Interlocked.CompareExchange(ref _running, 1, 0) != 0)
                return StartResult.AlreadyRunning;

            _linkedCts = CancellationTokenSource.CreateLinkedTokenSource(appToken);

            StartResult result = _engine.Start(filter, _linkedCts.Token);
            if (result != StartResult.Success)
            {
                CleanupRunningFlag();
                return result;
            }

            _captureTask = Task.Run(() =>
            {
                try
                {
                    _engine.RunCaptureLoop();
                }
                finally
                {
                    _linkedCts.Cancel(); // fuerza salida del monitor
                    CleanupRunningFlag();
                }
            }, _linkedCts.Token);

            _monitorTask = StartMonitorTask(_linkedCts.Token);
            return StartResult.Success;
        }

        public void Stop()
        {
            if (Interlocked.CompareExchange(ref _running, 0, 1) != 1)
                return;

            _engine.Stop();
            _linkedCts?.Cancel();
        }

        public async Task ShutdownAsync()
        {
            Stop();

            try
            {
                if (_captureTask != null)
                    await _captureTask.ConfigureAwait(false);

                if (_monitorTask != null)
                    await _monitorTask.ConfigureAwait(false);
            }
            finally
            {
                _linkedCts?.Dispose();
                (_engine as IDisposable)?.Dispose();
            }
        }

        private Task StartMonitorTask(CancellationToken ct)
    {
        return Task.Run(async () =>
        {
            long last = _engine.PacketCount;

            while (!ct.IsCancellationRequested)
            {
                await Task.Delay(1000, ct).ConfigureAwait(false);

                long current = _engine.PacketCount;
                long delta = current - last;

                _logger.Log(new PacketLogEntry(
                    Stopwatch.GetTimestamp(),
                    LogLevel.Info,
                    LogCode.PacketProcessed,
                    delta));

                _consoleView.UpdateStats(delta, current);

                last = current;
            }
        }, ct);
    }

        private void CleanupRunningFlag()
        {
            Interlocked.Exchange(ref _running, 0);
        }

        public void Dispose()
        {
            _linkedCts?.Dispose();
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Views\ConsoleStatsView.cs">
<![CDATA[
// NetShaper.UI/Views/ConsoleStatsView.cs
using System;

namespace NetShaper.UI.Views
{
    /// <summary>
    /// Console implementation of statistics view.
    /// Handles direct console manipulation (cursor positioning, formatting).
    /// </summary>
    public sealed class ConsoleStatsView : IConsoleView
    {
        private readonly int _displayLine;

        public ConsoleStatsView()
        {
            _displayLine = Console.CursorTop;
        }

        public void UpdateStats(long packetsPerSecond, long totalPackets)
        {
            Console.SetCursorPosition(0, _displayLine);
            Console.Write(
                $"PPS: {packetsPerSecond,10:N0} | Total paquetes: {totalPackets,12:N0}   ");
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Views\IConsoleView.cs">
<![CDATA[
// NetShaper.UI/Views/IConsoleView.cs
namespace NetShaper.UI.Views
{
    /// <summary>
    /// Interface for console UI rendering.
    /// Separates presentation logic from business logic (SRP).
    /// </summary>
    public interface IConsoleView
    {
        /// <summary>
        /// Updates the statistics display in the console.
        /// </summary>
        /// <param name="packetsPerSecond">Current packets processed per second.</param>
        /// <param name="totalPackets">Total packets processed.</param>
        void UpdateStats(long packetsPerSecond, long totalPackets);
    }
}
]]>
</file>
</codebase>