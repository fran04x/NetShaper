

# CONTEXTO: 33 ARCHIVOS
- NetShaper.Abstractions\IApplicationController.cs
- NetShaper.Abstractions\IEngine.cs
- NetShaper.Abstractions\IPacketCapture.cs
- NetShaper.Abstractions\IPacketLogger.cs
- NetShaper.Abstractions\NormativeAttributes.cs
- NetShaper.Abstractions\PacketCaptureConstants.cs
- NetShaper.Abstractions\PacketLogEntry.cs
- NetShaper.Abstractions\RuleAttributes.cs
- NetShaper.Abstractions\WrapperResult.cs
- NetShaper.Benchmarks\Benchmarks.cs
- NetShaper.Benchmarks\LatencyJitterBenchmark.cs
- NetShaper.Composition\ServiceCollectionExtensions.cs
- NetShaper.Domain\Test\ViolationTests.cs
- NetShaper.Engine\ArrayPoolDiagnostics.cs
- NetShaper.Engine\Engine.cs
- NetShaper.Engine\EngineTelemetry.cs
- NetShaper.Infrastructure\ConsolePacketLogger.cs
- NetShaper.Infrastructure\RingBufferPacketLogger.cs
- NetShaper.Native\NativeMethods.cs
- NetShaper.Native\WinDivertAdapter.cs
- NetShaper.Native\WinDivertAddress.cs
- NetShaper.Native\WinDivertHandle.cs
- NetShaper.Normative\NetShaperNormativeAnalyzer.cs
- NetShaper.StressTest\PerformanceTests.cs
- NetShaper.StressTest\Program.cs
- NetShaper.StressTest\RealTests.cs
- NetShaper.StressTest\TestServiceFactory.cs
- NetShaper.UI\Bootstrap.cs
- NetShaper.UI\Program.cs
- NetShaper.UI\Controllers\ConsoleApplicationController.cs
- NetShaper.UI\Controllers\EngineController.cs
- NetShaper.UI\Views\ConsoleStatsView.cs
- NetShaper.UI\Views\IConsoleView.cs

# CÓDIGO FUENTE
<codebase>
<file path="NetShaper.Abstractions\IApplicationController.cs">
<![CDATA[
// NetShaper.Abstractions/IApplicationController.cs
using System.Threading;
using System.Threading.Tasks;

namespace NetShaper.Abstractions
{
    public interface IApplicationController
    {
        Task<int> RunAsync(CancellationToken ct);
    }
}

]]>
</file>
<file path="NetShaper.Abstractions\IEngine.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    public interface IEngine : System.IDisposable
    {
        bool IsRunning { get; }
        long PacketCount { get; }

        StartResult Start(string filter, System.Threading.CancellationToken ct = default);
        void Stop();
        EngineResult RunCaptureLoop();
    }

    public enum StartResult
    {
        Success = 0,
        InvalidFilter = 1,
        AlreadyRunning = 2,
        Disposed = 3,
        OpenFailed = 4
    }

    public enum EngineResult
    {
        Success = 0,
        Stopped = 1,
        InvalidState = 2,
        InvalidHandle = 3,
        InvalidParameter = 4,
        Aborted = 5,
        TooManyErrors = 6
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\IPacketCapture.cs">
<![CDATA[
// NetShaper.Abstractions/IPacketCapture.cs
using System;
using System.Runtime.InteropServices;

namespace NetShaper.Abstractions
{
    public interface IPacketCapture : IDisposable
    {
        CaptureResult Open(string filter);
        CaptureResult Receive(Span<byte> buffer, out uint length, ref PacketMetadata metadata);
        CaptureResult ReceiveBatch(Span<byte> buffer, Span<PacketMetadata> metadataArray, out uint batchLength, out int packetCount);
        CaptureResult Send(ReadOnlySpan<byte> buffer, ref PacketMetadata metadata);
        void Shutdown();
        void CalculateChecksums(Span<byte> buffer, uint length, ref PacketMetadata metadata);
    }

    public enum CaptureResult
    {
        Success = 0,
        InvalidFilter = 1,
        InvalidHandle = 2,
        InvalidParameter = 3,
        OperationAborted = 4,
        ElementNotFound = 5,
        BufferTooSmall = 6,
        Unknown = 99
    }

    /// <summary>
    /// Packet metadata structure.
    /// Layout matches WINDIVERT_ADDRESS (WinDivert 2.2) for zero-copy interop.
    /// StructLayout is acceptable here as it defines a performance-critical contract.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct PacketMetadata
    {
        public long Timestamp;
        public uint InterfaceIndex;
        public uint SubInterfaceIndex;
        public byte Direction;
        public byte Loopback;
        public byte Impostor;
        public byte IpChecksum;
        public byte TcpChecksum;
        public byte UdpChecksum;
        public ushort Reserved1;
        public uint Reserved2;
        
        // BATCH MODE SUPPORT: Length of packet in batch (populated by ReceiveBatch)
        public uint Length;
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\IPacketLogger.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    public interface IPacketLogger
    {
        void Log(in PacketLogEntry entry);
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\NormativeAttributes.cs">
<![CDATA[
using System;

namespace NetShaper.Abstractions.Attributes
{
    // === Arquitectura ===

    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]
    public sealed class EngineSetupAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]
    public sealed class BoundaryAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Class)]
    public sealed class CompositionRootAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Method)]
    public sealed class HotPathAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Method)]
    public sealed class ProtocolParserAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Method)]
    public sealed class BatchProcessorAttribute : Attribute { }

    // === Dominio ===

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public sealed class EntityAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public sealed class ValueObjectAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public sealed class AggregateRootAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public sealed class DomainEventAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Property)]
    public sealed class DomainStateAttribute : Attribute { }

    // === Híbridos ===

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public sealed class EngineDomainAttribute : Attribute { }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public sealed class ZeroAllocationDomainAttribute : Attribute { }

    // === Uso / Aplicación ===

    [AttributeUsage(AttributeTargets.Method)]
    public sealed class UseCaseAttribute : Attribute { }

    // === Infraestructura de memoria ===

    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
    public sealed class BufferOwnerAttribute : Attribute { }
}

]]>
</file>
<file path="NetShaper.Abstractions\PacketCaptureConstants.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    /// <summary>
    /// Constantes compartidas para captura de paquetes y filtros WinDivert.
    /// </summary>
    public static class PacketCaptureConstants
    {
        /// <summary>
        /// Longitud máxima permitida para un filtro WinDivert.
        /// </summary>
        public const int MaxFilterLength = 1024;
    }
}

]]>
</file>
<file path="NetShaper.Abstractions\PacketLogEntry.cs">
<![CDATA[
using System.Runtime.InteropServices;

namespace NetShaper.Abstractions
{
    [StructLayout(LayoutKind.Sequential)]
    public readonly struct PacketLogEntry
    {
        public readonly long Timestamp;
        public readonly LogLevel Level;
        public readonly LogCode Code;
        public readonly long Value;

        public PacketLogEntry(long timestamp, LogLevel level, LogCode code, long value)
        {
            Timestamp = timestamp;
            Level = level;
            Code = code;
            Value = value;
        }
    }

    public enum LogLevel : byte
    {
        Info = 0,
        Warning = 1,
        Error = 2
    }

    public enum LogCode : ushort
    {
        None = 0,
        EngineStarted = 1,
        EngineStopped = 2,
        PacketProcessed = 3,
        RecvFailed = 4,
        SendFailed = 5,
        InvalidPacket = 6,
        OperationAborted = 7,
        InvalidHandle = 8,
        InvalidParameter = 9
    }
}
]]>
</file>
<file path="NetShaper.Abstractions\RuleAttributes.cs">
<![CDATA[
// NetShaper.Abstractions/RuleAttributes.cs
using System;

namespace NetShaper.Abstractions
{
    /// <summary>
    /// Marks methods that are allowed to use async/Task in Engine namespace.
    /// These are typically initialization or configuration methods that run outside the hot path.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class EngineSetupAttribute : Attribute { }

    /// <summary>
    /// Marks methods or classes that are application boundaries.
    /// These are allowed to catch generic Exception types.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class)]
    public sealed class BoundaryAttribute : Attribute { }

    /// <summary>
    /// Marks a class as the composition root for dependency injection.
    /// Each assembly should have at most one composition root.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class CompositionRootAttribute : Attribute { }

    /// <summary>
    /// Provides justification for rule violations that are acceptable.
    /// Used to document why a constructor exceeds normal dependency limits, etc.
    /// </summary>
    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Constructor)]
    public sealed class JustificationAttribute : Attribute 
    {
        public string Reason { get; }
        
        /// <summary>
        /// Creates a justification attribute with the specified reason.
        /// </summary>
        /// <param name="reason">The reason this violation is acceptable.</param>
        public JustificationAttribute(string reason) => Reason = reason;
    }
}

]]>
</file>
<file path="NetShaper.Abstractions\WrapperResult.cs">
<![CDATA[
namespace NetShaper.Abstractions
{
    public enum WrapperResult
    {
        Success = 0,
        InvalidFilter = 1,
        InvalidHandle = 2,
        InvalidParameter = 3,
        OperationAborted = 4,
        ElementNotFound = 5,
        BufferTooSmall = 6,
        Unknown = 99
    }
}
]]>
</file>
<file path="NetShaper.Benchmarks\Benchmarks.cs">
<![CDATA[
// NetShaper.Benchmarks/Benchmarks.cs
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;
using NetShaper.Engine;

namespace NetShaper.Benchmarks
{
    internal static class Program
    {
        private static void Main(string[] args)
        {
            // Run both throughput and latency/jitter benchmarks
            var summary = BenchmarkRunner.Run(typeof(Program).Assembly);
        }
    }

    [MemoryDiagnoser]
    [ThreadingDiagnoser]
    public class EngineBenchmarks
    {
        private const int Port = 55556;
        private const int PacketCount = 10000;

        private Engine.Engine _engine = null!;
        private CancellationTokenSource _cts = null!;
        private Task _captureTask = null!;
        private Socket _socket = null!;
        private IPacketLogger _logger = null!;
        private IPacketCapture _capture = null!;

        private byte[] _small = null!;
        private byte[] _medium = null!;
        private byte[] _large = null!;

        [GlobalSetup]
        public void Setup()
        {
            _small = new byte[64];
            _medium = new byte[512];
            _large = new byte[1400];

            _socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            _socket.Connect(IPAddress.Loopback, Port);

            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();

            _logger = provider.GetRequiredService<IPacketLogger>();
            _capture = provider.GetRequiredService<IPacketCapture>();

            Func<IPacketCapture> captureFactory = () => _capture;
            _engine = new Engine.Engine(_logger, captureFactory, threadCount: 1);
            _cts = new CancellationTokenSource();

            var result = _engine.Start($"outbound and udp.DstPort == {Port}", _cts.Token);
            if (result != StartResult.Success)
                throw new InvalidOperationException(result.ToString());

            _captureTask = Task.Factory.StartNew(
                static state =>
                {
                    var engine = (Engine.Engine)state!;
                    engine.RunCaptureLoop();
                },
                _engine,
                TaskCreationOptions.LongRunning);

            Thread.Sleep(200);
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _engine.Stop();
            _cts.Cancel();

            try { _captureTask.Wait(1000); } catch { }

            _engine.Dispose();
            _cts.Dispose();
            _socket.Dispose();
            _capture.Dispose();
        }

        [Benchmark(Description = "10k packets - 64 bytes")]
        public void SmallPackets()
        {
            for (int i = 0; i < PacketCount; i++)
            {
                _socket.Send(_small);
                if ((i & 255) == 0) Thread.Yield();
            }
        }

        [Benchmark(Description = "10k packets - 512 bytes")]
        public void MediumPackets()
        {
            for (int i = 0; i < PacketCount; i++)
            {
                _socket.Send(_medium);
                if ((i & 255) == 0) Thread.Yield();
            }
        }

        [Benchmark(Description = "10k packets - 1400 bytes")]
        public void LargePackets()
        {
            for (int i = 0; i < PacketCount; i++)
            {
                _socket.Send(_large);
                if ((i & 255) == 0) Thread.Yield();
            }
        }
    }
}

]]>
</file>
<file path="NetShaper.Benchmarks\LatencyJitterBenchmark.cs">
<![CDATA[
// NetShaper.Benchmarks/LatencyJitterBenchmark.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;

namespace NetShaper.Benchmarks
{
    /// <summary>
    /// Benchmark de latencia individual y jitter.
    /// Optimizado para hardware lento - expectativas realistas.
    /// </summary>
    [MemoryDiagnoser]
    [SimpleJob(warmupCount: 1, iterationCount: 3)]
    public class LatencyJitterBenchmark
    {
        private const int Port = 55558;
        private const int SampleCount = 500; // Reducido para hardware lento
        
        private IEngine _engine = null!;
        private CancellationTokenSource _cts = null!;
        private Task _captureTask = null!;
        private Socket _socket = null!;
        private byte[] _packet = null!;

        [GlobalSetup]
        public void Setup()
        {
            _packet = new byte[512];
            _socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            _socket.Connect(IPAddress.Loopback, Port);

            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();

            _engine = provider.GetRequiredService<IEngine>();
            _cts = new CancellationTokenSource();

            var result = _engine.Start($"outbound and udp.DstPort == {Port}", _cts.Token);
            if (result != StartResult.Success)
                throw new InvalidOperationException($"Start failed: {result}");

            _captureTask = Task.Run(() => _engine.RunCaptureLoop(), _cts.Token);

            // Warmup ligero
            for (int i = 0; i < 100; i++)
            {
                _socket.Send(_packet);
                Thread.Sleep(5); // Delay para no saturar
            }

            Thread.Sleep(500);
        }

        [GlobalCleanup]
        public void Cleanup()
        {
            _engine.Stop();
            _cts.Cancel();
            try { _captureTask.Wait(2000); } catch { }
            _engine.Dispose();
            _cts.Dispose();
            _socket.Dispose();
        }

        /// <summary>
        /// Mide latencia de procesamiento individual (send to processed).
        /// Envía 1 paquete, espera que se procese, mide tiempo total.
        /// </summary>
        [Benchmark(Description = "Individual Latency (500 samples)")]
        public LatencyStats MeasureIndividualLatency()
        {
            var latencies = new List<long>(SampleCount);

            for (int i = 0; i < SampleCount; i++)
            {
                long baseline = _engine.PacketCount;
                long start = Stopwatch.GetTimestamp();

                _socket.Send(_packet);

                // Esperar hasta que el paquete sea procesado
                while (_engine.PacketCount == baseline)
                {
                    Thread.SpinWait(50);
                }

                long end = Stopwatch.GetTimestamp();
                latencies.Add(end - start);

                // Pequeño delay entre mediciones para evitar saturación
                Thread.Sleep(2);
            }

            var result = CalculateLatencyStats(latencies);
            
            // Guardar en Desktop con ruta absoluta
            try
            {
                string resultsPath = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
                    "netshaper_latency_results.txt");
                File.AppendAllText(resultsPath, 
                    $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] LATENCY: {result}\n");
            }
            catch { /* Ignore file errors in benchmark */ }
            
            return result;
        }

        /// <summary>
        /// Mide jitter enviando paquetes a ritmo constante (100 PPS).
        /// </summary>
        [Benchmark(Description = "Jitter at 100 PPS")]
        public JitterStats MeasureJitterAt100Pps()
        {
            var latencies = new List<long>(SampleCount);
            long intervalTicks = Stopwatch.Frequency / 100; // 10ms interval = 100 PPS

            long nextSend = Stopwatch.GetTimestamp();

            for (int i = 0; i < SampleCount; i++)
            {
                long baseline = _engine.PacketCount;
                long start = Stopwatch.GetTimestamp();

                // Esperar hasta el momento exacto de envío
                while (Stopwatch.GetTimestamp() < nextSend)
                    Thread.SpinWait(10);

                _socket.Send(_packet);
                nextSend += intervalTicks;

                // Esperar procesamiento
                while (_engine.PacketCount == baseline)
                {
                    Thread.SpinWait(50);
                }

                long end = Stopwatch.GetTimestamp();
                latencies.Add(end - start);
            }

            var result = CalculateJitterStats(latencies);
            
            // Guardar en Desktop con ruta absoluta
            try
            {
                string resultsPath = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
                    "netshaper_latency_results.txt");
                File.AppendAllText(resultsPath, 
                    $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] JITTER: {result}\n");
            }
            catch { /* Ignore file errors in benchmark */ }
            
            return result;
        }

        private static LatencyStats CalculateLatencyStats(List<long> latencies)
        {
            latencies.Sort();
            double ToMicroseconds(long ticks) => (ticks * 1_000_000.0) / Stopwatch.Frequency;

            return new LatencyStats
            {
                P50_us = ToMicroseconds(latencies[latencies.Count / 2]),
                P95_us = ToMicroseconds(latencies[(int)(latencies.Count * 0.95)]),
                P99_us = ToMicroseconds(latencies[(int)(latencies.Count * 0.99)]),
                Min_us = ToMicroseconds(latencies[0]),
                Max_us = ToMicroseconds(latencies[^1]),
                Mean_us = ToMicroseconds((long)latencies.Average())
            };
        }

        private static JitterStats CalculateJitterStats(List<long> latencies)
        {
            double ToMicroseconds(long ticks) => (ticks * 1_000_000.0) / Stopwatch.Frequency;

            var mean = latencies.Average();
            var variance = latencies.Select(l => Math.Pow(l - mean, 2)).Average();
            var stdDev = Math.Sqrt(variance);

            var deltas = new List<double>();
            for (int i = 1; i < latencies.Count; i++)
            {
                deltas.Add(Math.Abs(latencies[i] - latencies[i - 1]));
            }

            deltas.Sort();

            return new JitterStats
            {
                StdDev_us = ToMicroseconds((long)stdDev),
                MaxJitter_us = ToMicroseconds((long)deltas.Max()),
                AvgJitter_us = ToMicroseconds((long)deltas.Average()),
                P95Jitter_us = ToMicroseconds((long)deltas[(int)(deltas.Count * 0.95)])
            };
        }
    }

    public struct LatencyStats
    {
        public double P50_us;
        public double P95_us;
        public double P99_us;
        public double Min_us;
        public double Max_us;
        public double Mean_us;

        public override string ToString() =>
            $"P50={P50_us:F0}μs P95={P95_us:F0}μs P99={P99_us:F0}μs (Min={Min_us:F0} Max={Max_us:F0})";
    }

    public struct JitterStats
    {
        public double StdDev_us;
        public double MaxJitter_us;
        public double AvgJitter_us;
        public double P95Jitter_us;

        public override string ToString() =>
            $"Avg={AvgJitter_us:F0}μs P95={P95Jitter_us:F0}μs Max={MaxJitter_us:F0}μs (σ={StdDev_us:F0})";
    }
}
]]>
</file>
<file path="NetShaper.Composition\ServiceCollectionExtensions.cs">
<![CDATA[
// NetShaper.Composition/ServiceCollectionExtensions.cs
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Infrastructure;
using NetShaper.Native;

namespace NetShaper.Composition
{
    /// <summary>
    /// Composition root for NetShaper dependency injection.
    /// This is the ONLY place where concrete implementations are wired to abstractions.
    /// </summary>
    [CompositionRoot]
    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// Registers all NetShaper core services including packet capture, logging, and engine.
        /// This method wires all concrete implementations to their abstractions.
        /// </summary>
        /// <param name="services">The service collection to add services to.</param>
        /// <returns>The service collection for chaining.</returns>
        public static IServiceCollection AddNetShaperServices(this IServiceCollection services)
        {
            // Register packet logger as singleton (maintains state across application lifetime)
            services.AddSingleton<IPacketLogger, RingBufferPacketLogger>();
            
            // Register packet capture as transient (new instance per engine)
            services.AddTransient<IPacketCapture, WinDivertAdapter>();
            
            // Register Engine as IEngine (83k PPS with 1 thread, minimal resources)
            // Factory pattern: creates fresh IPacketCapture instance per thread
            services.AddTransient<IEngine>(serviceProvider =>
            {
                var logger = serviceProvider.GetRequiredService<IPacketLogger>();
                
                // Factory to create IPacketCapture instances (one per thread in pool)
                Func<IPacketCapture> captureFactory = () => 
                    serviceProvider.GetRequiredService<IPacketCapture>();
                
                // Default: 1 thread (optimal for Celeron N5100, 83k PPS)
                // Future: make configurable via settings
                const int threadCount = 1;
                
                return new Engine.Engine(logger, captureFactory, threadCount);
            });
            
            return services;
        }
    }
}

]]>
</file>
<file path="NetShaper.Domain\Test\ViolationTests.cs">
<![CDATA[
using System;

namespace NetShaper.Domain.Test
{
    // VIOLACIÓN R2.06: Comentario TODO encontrado.
    // TODO: Resolver este problema.

    public class ViolationTests
    {
        // VIOLACIÓN R7.01: El campo privado debe seguir el formato _camelCase.
        private int BadlyNamedField;

        public ViolationTests()
        {
            // VIOLACIÓN R1.03: El constructor tiene demasiados parámetros (5). El límite es 4.
            this.BadlyNamedField = 0;
        }

        // VIOLACIÓN R7.02: El miembro público debe usar PascalCase.
        public void badMethodName()
        {
            try
            {
                // VIOLACIÓN R12.03: El número 123 es un número mágico.
                var magic = 123;
                if (System.DateTime.Now.Day == magic)
                    throw new Exception("Test");
            }
            // VIOLACIÓN R6.03: Bloque catch vacío.
            catch
            {
            }
        }
    }
}

]]>
</file>
<file path="NetShaper.Engine\ArrayPoolDiagnostics.cs">
<![CDATA[
// NetShaper.Engine/ArrayPoolDiagnostics.cs
using System.Diagnostics;
using System.Threading;

namespace NetShaper.Engine
{
    /// <summary>
    /// Diagnósticos para rastrear el balance de ArrayPool rent/return.
    /// Solo activo en builds DEBUG.
    /// </summary>
    internal static class ArrayPoolDiagnostics
    {
        private static int _rentCount;
        private static int _returnCount;

        public static void RecordRent()
        {
            Interlocked.Increment(ref _rentCount);
        }

        public static void RecordReturn()
        {
            Interlocked.Increment(ref _returnCount);
        }

        [Conditional("DEBUG")]
        public static void ValidateBalance()
        {
            // Simple read with memory barrier - good enough for DEBUG diagnostics
            // Potential race is acceptable since this is only for developer awareness
            int rents = Volatile.Read(ref _rentCount);
            int returns = Volatile.Read(ref _returnCount);
            
            Debug.Assert(rents == returns, 
                $"ArrayPool mismatch: Rent={rents}, Return={returns}");
        }
    }
}

]]>
</file>
<file path="NetShaper.Engine\Engine.cs">
<![CDATA[
// NetShaper.Engine/Engine.cs
using System;
using System.Runtime.CompilerServices;
using System.Threading;
using NetShaper.Abstractions;

namespace NetShaper.Engine
{
    /// <summary>
    /// Multi-threaded batch processing engine using WinDivertRecvEx.
    /// Achieves 83k PPS with 1 thread, 2.4x improvement over baseline.
    /// </summary>
    public sealed class Engine : IEngine
    {
        private readonly IPacketLogger _logger;
        private readonly Func<IPacketCapture> _captureFactory;
        private readonly int _threadCount;
        private CancellationTokenSource _cts;  // Not readonly - recreated on each Start()
        
        // Per-thread resources
        private readonly IPacketCapture[] _captures;
        private readonly byte[][] _buffers;
        private readonly Thread[] _threads;
        
        private readonly EngineTelemetry _telemetry;
        private int _isRunning;
        private int _disposed;
        
        private const int BufferSize = 128 * 1024; // 128KB for batch
        private const int BatchSize = 64; // Max packets per batch
        
        public Engine(IPacketLogger logger, Func<IPacketCapture> captureFactory, int threadCount)
        {
            if (threadCount <= 0 || threadCount > 16)
                throw new ArgumentOutOfRangeException(nameof(threadCount));
            
            _logger = logger;
            _captureFactory = captureFactory ?? throw new ArgumentNullException(nameof(captureFactory));
            _threadCount = threadCount;
            _cts = new CancellationTokenSource();
            _telemetry = new EngineTelemetry();
            
            // Initialize arrays
            _captures = new IPacketCapture[threadCount];
            _buffers = new byte[threadCount][];
            _threads = new Thread[threadCount];
            
            // Pre-allocate buffers and create capture instances
            for (int i = 0; i < threadCount; i++)
            {
                _captures[i] = _captureFactory();
                _buffers[i] = System.Buffers.ArrayPool<byte>.Shared.Rent(BufferSize);
                ArrayPoolDiagnostics.RecordRent();
            }
        }
        
        // IEngine interface implementation
        public bool IsRunning => Interlocked.CompareExchange(ref _isRunning, 0, 0) == 1;
        public long PacketCount => _telemetry.PacketsProcessed;
        
        public StartResult Start(string filter, CancellationToken ct = default)
        {
            // Link external cancellation token to internal CTS
            if (ct != default && ct.CanBeCanceled)
            {
                ct.Register(() => _cts.Cancel());
            }
            
            return Start(filter);
        }
        
        public EngineResult RunCaptureLoop()
        {
            // Engine manages threads internally, so this is a no-op
            // Threads are already running after Start()
            // Wait for cancellation or Stop()
            while (IsRunning && !_cts.Token.IsCancellationRequested)
            {
                Thread.Sleep(100);
            }
            
            return EngineResult.Success;
        }
        
        public StartResult Start(string filter)
        {
            if (Interlocked.CompareExchange(ref _isRunning, 1, 0) != 0)
                return StartResult.AlreadyRunning;
            
            // Create NEW CTS before disposing old one to prevent ObjectDisposedException
            // Worker threads may still be reading _cts.Token during rapid Start/Stop cycles
            var newCts = new CancellationTokenSource();
            var oldCts = Interlocked.Exchange(ref _cts, newCts);
            
            // Dispose old CTS asynchronously with grace period for pending reads
            if (oldCts != null)
            {
                System.Threading.Tasks.Task.Run(() =>
                {
                    Thread.Sleep(500);  // Grace period for threads to finish reading Token
                    try { oldCts.Dispose(); } catch { /* best effort */ }
                });
            }
            
            // Reset telemetry for new session
            _telemetry.Reset();
            
            // Open ALL handles with the same filter
            for (int i = 0; i < _threadCount; i++)
            {
                CaptureResult result = _captures[i].Open(filter);
                if (result != CaptureResult.Success)
                {
                    Interlocked.Exchange(ref _isRunning, 0);
                    return StartResult.OpenFailed;
                }
            }
            
            _telemetry.Reset();
            
            // Launch worker threads
            for (int i = 0; i < _threadCount; i++)
            {
                int threadIdx = i;
                _threads[threadIdx] = new Thread(() => ProcessLoopWorker(threadIdx))
                {
                    IsBackground = true,
                    Name = $"BatchWorker-{threadIdx}",
                    Priority = ThreadPriority.AboveNormal
                };
                _threads[threadIdx].Start();
            }
            
            return StartResult.Success;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool ShouldStop() => _cts.Token.IsCancellationRequested;
        
        private void ProcessLoopWorker(int threadIdx)
        {
            IPacketCapture capture = _captures[threadIdx];
            byte[] bufferArray = _buffers[threadIdx];
            
            // stackalloc metadata array for batch (zero allocation)
            Span<PacketMetadata> metadataBatch = stackalloc PacketMetadata[BatchSize];
            
            // Local counters
            long localPackets = 0;
            long localRecvErrors = 0;
            long localSendErrors = 0;
            long localInvalidPackets = 0;
            
            // For periodic telemetry updates (so UI shows real-time counts)
            const long TelemetryFlushInterval = 1000;
            
            try
            {
                while (true)
                {
                    if (ShouldStop())
                        break;
                    
                    Span<byte> buffer = bufferArray.AsSpan(0, BufferSize);
                    
                    // Receive batch of packets
                    CaptureResult recv = capture.ReceiveBatch(
                        buffer,
                        metadataBatch,
                        out uint totalBytes,
                        out int packetCount);
                    
                    if (recv != CaptureResult.Success)
                    {
                        if (recv == CaptureResult.InvalidHandle || recv == CaptureResult.OperationAborted)
                            break;
                        
                        localRecvErrors++;
                        continue;
                    }
                    
                    // Process batch using native-parsed lengths
                    ProcessBatch(capture, buffer, metadataBatch, packetCount,
                        ref localPackets, ref localSendErrors, ref localInvalidPackets);
                    
                    // Periodic telemetry flush for real-time UI updates
                    if (localPackets >= TelemetryFlushInterval)
                    {
                        _telemetry.AddPackets(localPackets);
                        _telemetry.AddRecvErrors(localRecvErrors);
                        _telemetry.AddSendErrors(localSendErrors);
                        _telemetry.AddInvalidPackets(localInvalidPackets);
                        
                        localPackets = 0;
                        localRecvErrors = 0;
                        localSendErrors = 0;
                        localInvalidPackets = 0;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // Expected during clean shutdown via CancellationToken
            }
            catch (ObjectDisposedException)
            {
                // Expected if capture was disposed externally during rapid Stop
            }
            // Do NOT catch Exception - let critical errors propagate to UnhandledExceptionHandler
            finally
            {
                // Final flush of any remaining counters
                if (localPackets > 0) _telemetry.AddPackets(localPackets);
                if (localRecvErrors > 0) _telemetry.AddRecvErrors(localRecvErrors);
                if (localSendErrors > 0) _telemetry.AddSendErrors(localSendErrors);
                if (localInvalidPackets > 0) _telemetry.AddInvalidPackets(localInvalidPackets);
            }
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ProcessBatch(
            IPacketCapture capture,
            Span<byte> buffer,
            Span<PacketMetadata> metadata,
            int count,
            ref long packetsProcessed,
            ref long sendErrors,
            ref long invalidPackets)
        {
            uint offset = 0;
            
            for (int i = 0; i < count; i++)
            {
                ref PacketMetadata meta = ref metadata[i];
                uint packetLen = meta.Length;
                
                // Validate packet length with structured logging
                if (packetLen == 0)
                {
                    _logger.Log(new PacketLogEntry(
                        System.Diagnostics.Stopwatch.GetTimestamp(),
                        LogLevel.Warning,
                        LogCode.InvalidPacket,
                        0));  // Value = 0 indica zero-length
                    
                    invalidPackets++;
                    continue;  // Continue processing next packet, don't break entire batch
                }
                
                if (packetLen > BufferSize)
                {
                    _logger.Log(new PacketLogEntry(
                        System.Diagnostics.Stopwatch.GetTimestamp(),
                        LogLevel.Error,
                        LogCode.InvalidPacket,
                        (long)packetLen));  // Value = packetLen excedido
                    
                    invalidPackets++;
                    continue;  // Continue processing next packet
                }
                
                if (offset + packetLen > buffer.Length)
                {
                    _logger.Log(new PacketLogEntry(
                        System.Diagnostics.Stopwatch.GetTimestamp(),
                        LogLevel.Error,
                        LogCode.InvalidPacket,
                        (long)offset));  // Value = offset donde falló
                    
                    invalidPackets++;
                    break;  // Buffer overflow: error en batch completo, no podemos continuar
                }
                
                Span<byte> packet = buffer.Slice((int)offset, (int)packetLen);
                
                // Calculate checksums and send individually
                capture.CalculateChecksums(packet, packetLen, ref meta);
                
                CaptureResult sendResult = capture.Send(packet, ref meta);
                if (sendResult == CaptureResult.Success)
                {
                    packetsProcessed++;
                }
                else if (sendResult != CaptureResult.InvalidHandle)
                {
                    sendErrors++;
                }
                
                offset += packetLen;
            }
        }
        
        public void Stop()
        {
            _cts.Cancel();
            
            // Unblock WinDivertRecv calls
            if (_captures != null)
            {
                foreach (var capture in _captures)
                {
                    try { capture?.Shutdown(); } catch { /* best effort */ }
                }
            }
            
            // Wait for threads
            for (int i = 0; i < _threadCount; i++)
            {
                if (_threads[i] != null && _threads[i].IsAlive)
                {
                    _threads[i].Join(2000);  // Best effort join with timeout
                }
            }
            
            Interlocked.Exchange(ref _isRunning, 0);
        }
        
        public long TotalPacketsProcessed => _telemetry.PacketsProcessed;
        public int ThreadCount => _threadCount;
        
        public void Dispose()
        {
            if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 0)
            {
                Stop();
                _cts.Dispose();
                
                // Cleanup per-thread resources
                for (int i = 0; i < _threadCount; i++)
                {
                    // Return buffer
                    if (_buffers[i] != null)
                    {
                        System.Buffers.ArrayPool<byte>.Shared.Return(_buffers[i]);
                        ArrayPoolDiagnostics.RecordReturn();
                    }
                    
                    // Dispose capture handle
                    (_captures[i] as IDisposable)?.Dispose();
                }
            }
        }
    }
}

]]>
</file>
<file path="NetShaper.Engine\EngineTelemetry.cs">
<![CDATA[
// NetShaper.Engine/EngineTelemetry.cs
using System.Runtime.CompilerServices;
using System.Threading;

namespace NetShaper.Engine
{
    internal sealed class EngineTelemetry
    {
        private long _packetsProcessed;
        private long _recvErrors;
        private long _sendErrors;
        private long _invalidPackets;
        private long _consecutiveErrors;

        // Propiedades con Volatile.Read para lecturas cross-thread seguras
        public long PacketsProcessed => Volatile.Read(ref _packetsProcessed);
        public long RecvErrors => Volatile.Read(ref _recvErrors);
        public long SendErrors => Volatile.Read(ref _sendErrors);
        public long InvalidPackets => Volatile.Read(ref _invalidPackets);
        public long ConsecutiveErrors => Volatile.Read(ref _consecutiveErrors);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordPacket()
        {
            Interlocked.Increment(ref _packetsProcessed);
            Interlocked.Exchange(ref _consecutiveErrors, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordRecvError()
        {
            Interlocked.Increment(ref _recvErrors);
            Interlocked.Increment(ref _consecutiveErrors);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordSendError()
        {
            Interlocked.Increment(ref _sendErrors);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RecordInvalidPacket()
        {
            Interlocked.Increment(ref _invalidPackets);
        }

        public void AddPackets(long count)
        {
            Interlocked.Add(ref _packetsProcessed, count);
        }

        public void AddRecvErrors(long count)
        {
            Interlocked.Add(ref _recvErrors, count);
            Interlocked.Add(ref _consecutiveErrors, count);
        }

        public void AddSendErrors(long count)
        {
            Interlocked.Add(ref _sendErrors, count);
        }

        public void AddInvalidPackets(long count)
        {
            Interlocked.Add(ref _invalidPackets, count);
        }

        public void Reset()
        {
            Interlocked.Exchange(ref _packetsProcessed, 0);
            Interlocked.Exchange(ref _recvErrors, 0);
            Interlocked.Exchange(ref _sendErrors, 0);
            Interlocked.Exchange(ref _invalidPackets, 0);
            Interlocked.Exchange(ref _consecutiveErrors, 0);
        }
    }
}
]]>
</file>
<file path="NetShaper.Infrastructure\ConsolePacketLogger.cs">
<![CDATA[
using System;
using System.Diagnostics;
using NetShaper.Abstractions;

namespace NetShaper.Infrastructure
{
    public sealed class ConsolePacketLogger : IPacketLogger
    {
        private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;

        public void Log(in PacketLogEntry entry)
        {
            long ticks = (long)(entry.Timestamp * TickFrequency);
            TimeSpan elapsed = new TimeSpan(ticks);

            string levelStr = entry.Level switch
            {
                LogLevel.Info => "INFO",
                LogLevel.Warning => "WARN",
                LogLevel.Error => "ERROR",
                _ => "UNKN"
            };

            string codeStr = entry.Code switch
            {
                LogCode.EngineStarted => "Engine Started",
                LogCode.EngineStopped => "Engine Stopped",
                LogCode.PacketProcessed => "Packet Processed",
                LogCode.RecvFailed => "Recv Failed",
                LogCode.SendFailed => "Send Failed",
                LogCode.InvalidPacket => "Invalid Packet",
                LogCode.OperationAborted => "Operation Aborted",
                LogCode.InvalidHandle => "Invalid Handle",
                LogCode.InvalidParameter => "Invalid Parameter",
                _ => "Unknown"
            };

            Console.WriteLine($"[{elapsed.TotalSeconds:F3}s] [{levelStr}] {codeStr} (Value: {entry.Value})");
        }
    }
}
]]>
</file>
<file path="NetShaper.Infrastructure\RingBufferPacketLogger.cs">
<![CDATA[
using System;
using System.Threading;
using NetShaper.Abstractions;

namespace NetShaper.Infrastructure
{
    public sealed class RingBufferPacketLogger : IPacketLogger
    {
        private readonly PacketLogEntry[] _buffer;
        private readonly int _mask;
        private int _index;

        public RingBufferPacketLogger(int powerOfTwoSize = 4096)
        {
            if (powerOfTwoSize <= 0)
                throw new ArgumentOutOfRangeException(nameof(powerOfTwoSize), powerOfTwoSize, "Size must be positive");

            if ((powerOfTwoSize & (powerOfTwoSize - 1)) != 0)
                throw new ArgumentException($"Size must be a power of two. Provided: {powerOfTwoSize}", nameof(powerOfTwoSize));

            _buffer = new PacketLogEntry[powerOfTwoSize];
            _mask = powerOfTwoSize - 1;
            _index = -1;
        }

        public void Log(in PacketLogEntry entry)
        {
            int i = Interlocked.Increment(ref _index) & _mask;
            _buffer[i] = entry;
        }

        public PacketLogEntry[] Snapshot()
        {
            return (PacketLogEntry[])_buffer.Clone();
        }
    }
}
]]>
</file>
<file path="NetShaper.Native\NativeMethods.cs">
<![CDATA[
// NetShaper.Native\NativeMethods.cs
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace NetShaper.Native
{
    public static partial class NativeMethods
    {
        private const string DllName = "WinDivert.dll";

        public const int LayerNetwork = 0;
        public const int WinDivertShutdownRecv = 1;
        public const int WinDivertShutdownSend = 2;
        public const int WinDivertShutdownBoth = 3;

        [LibraryImport(DllName, EntryPoint = "WinDivertOpen", SetLastError = true, StringMarshalling = StringMarshalling.Utf8)]
        [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })]
        public static partial WinDivertHandle WinDivertOpen(
            string filter,
            int layer,
            short priority,
            long flags);

        [LibraryImport(DllName, EntryPoint = "WinDivertShutdown", SetLastError = true)]
        [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static partial bool WinDivertShutdown(
            WinDivertHandle handle, 
            int mode);
    }
}
]]>
</file>
<file path="NetShaper.Native\WinDivertAdapter.cs">
<![CDATA[
// NetShaper.Native/WinDivertAdapter.cs
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NetShaper.Abstractions;

namespace NetShaper.Native
{
    public sealed partial class WinDivertAdapter : IPacketCapture
    {
        private const int MaxFilterLength = PacketCaptureConstants.MaxFilterLength;
        private const int ShutdownRecv = 1;

        private WinDivertHandle? _handle;
        private int _disposed;
        private int _shutdownFlag;  // 0 = not shutdown, 1 = shutdown initiated
        private int _activeOperations;  // Counter for concurrent Receive/Send operations

        static WinDivertAdapter()
        {
            ValidateStructLayout();
        }

        public CaptureResult Open(string filter)
        {
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return CaptureResult.InvalidHandle;
            if (string.IsNullOrWhiteSpace(filter))
                return CaptureResult.InvalidFilter;
            if (filter.Length > MaxFilterLength)
                return CaptureResult.InvalidFilter;
            if (_handle != null && !_handle.IsInvalid)
                return CaptureResult.InvalidHandle;

            WinDivertHandle? handle = null;

            try
            {
                handle = WinDivertOpenNative(filter, 0, 0, 0);
                if (handle.IsInvalid)
                {
                    int error = Marshal.GetLastWin32Error();
                    // REMOVED: Console.WriteLine to prevent allocations in hot-path
                    // Error code is already returned via MapError(error) below
                    handle.Dispose();
                    return MapError(error);
                }

                _handle = handle;
            
                // Reset shutdown flag to allow re-open after shutdown (reentrancy support)
                Interlocked.Exchange(ref _shutdownFlag, 0);
            
                return CaptureResult.Success;
            }
            catch (Exception)
            {
                // REMOVED: Console.WriteLine to prevent allocations in hot-path
                // Exception is re-thrown to caller for proper handling
                handle?.Dispose();
                throw;
            }
        }

        public unsafe CaptureResult Receive(
            Span<byte> buffer,
            out uint length,
            ref PacketMetadata metadata)
        {
            length = 0;
            
            // Prevent disposal while operation is active
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return CaptureResult.InvalidHandle;
            
            Interlocked.Increment(ref _activeOperations);
            
            try
            {
                WinDivertHandle? handle = _handle;
                if (handle == null || handle.IsInvalid)
                    return CaptureResult.InvalidHandle;
                
                if (buffer.IsEmpty)
                    return CaptureResult.BufferTooSmall;

                fixed (byte* pBuf = buffer)
                {
                    WinDivertAddress addr = ToWinDivertAddress(ref metadata);
                    WinDivertAddress* pAddr = &addr;

                    bool success = WinDivertRecvNative(
                        handle,
                        pBuf,
                        (uint)buffer.Length,
                        out length,
                        pAddr);

                    if (!success)
                        return MapError(Marshal.GetLastWin32Error());

                    metadata = FromWinDivertAddress(ref addr);
                    return CaptureResult.Success;
                }
            }
            catch (ObjectDisposedException)
            {
                return CaptureResult.InvalidHandle;
            }
            finally
            {
                Interlocked.Decrement(ref _activeOperations);
            }
        }

        public unsafe CaptureResult ReceiveBatch(
            Span<byte> buffer,
            Span<PacketMetadata> metadataArray,
            out uint batchLength,
            out int packetCount)
        {
            batchLength = 0;
            packetCount = 0;
            
            // Prevent disposal while operation is active
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return CaptureResult.InvalidHandle;
            
            Interlocked.Increment(ref _activeOperations);
            
            try
            {
                WinDivertHandle? handle = _handle;
                if (handle == null || handle.IsInvalid)
                    return CaptureResult.InvalidHandle;
                
                if (buffer.IsEmpty || metadataArray.IsEmpty)
                    return CaptureResult.BufferTooSmall;

                const int MaxBatchSize = 64;
                int maxPackets = Math.Min(metadataArray.Length, MaxBatchSize);
                
                // Stack-allocate WinDivertAddress array for batch
                WinDivertAddress* pAddrArray = stackalloc WinDivertAddress[maxPackets];
                
                fixed (byte* pBuf = buffer)
                {
                    uint readLen = 0;  // ← CORRECTED: was ulong
                    uint addrLen = (uint)(maxPackets * sizeof(WinDivertAddress));
                    
                    // Call WinDivertRecvEx (batch mode)
                    bool success = WinDivertRecvExNative(
                        handle,
                        pBuf,
                        (uint)buffer.Length,
                        &readLen,  // ← CORRECTED: now uint* instead of ulong*
                        0,  // flags = 0 (synchronous)
                        pAddrArray,
                        &addrLen,
                        null);  // pOverlapped = null (synchronous)

                    if (!success)
                        return MapError(Marshal.GetLastWin32Error());

                    batchLength = readLen;  // ← No cast needed now
                    packetCount = (int)(addrLen / sizeof(WinDivertAddress));
                    
                    // Parse IP headers to extract packet lengths
                    // WinDivert packs packets tightly: [Pkt1][Pkt2][Pkt3]...
                    uint offset = 0;
                    for (int i = 0; i < packetCount; i++)
                    {
                        ref PacketMetadata meta = ref metadataArray[i];
                        ref WinDivertAddress addr = ref pAddrArray[i];
                        
                        // Convert WinDivertAddress to PacketMetadata
                        meta = FromWinDivertAddress(ref addr);
                        
                        // Parse packet length using helper method
                        uint packetLength = ParsePacketLength(pBuf, offset, readLen);
                        if (packetLength == 0)
                        {
                            meta.Length = 0;
                            break;  // Invalid or unknown packet
                        }
                        
                        meta.Length = packetLength;
                        offset += packetLength;
                    }

                    return CaptureResult.Success;
                }
            }
            catch (ObjectDisposedException)
            {
                return CaptureResult.InvalidHandle;
            }
            finally
            {
                Interlocked.Decrement(ref _activeOperations);
            }
        }

        public unsafe CaptureResult Send(
            ReadOnlySpan<byte> buffer,
            ref PacketMetadata metadata)
        {
            // Prevent disposal while operation is active
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return CaptureResult.InvalidHandle;
            
            Interlocked.Increment(ref _activeOperations);
            
            try
            {
                WinDivertHandle? handle = _handle;
                if (handle == null || handle.IsInvalid)
                    return CaptureResult.InvalidHandle;
                
                if (buffer.IsEmpty)
                    return CaptureResult.InvalidParameter;

                fixed (byte* pBuf = buffer)
                {
                    WinDivertAddress addr = ToWinDivertAddress(ref metadata);
                    WinDivertAddress* pAddr = &addr;

                    bool success = WinDivertSendNative(
                        handle,
                        pBuf,
                        (uint)buffer.Length,
                        out uint _,
                        pAddr);

                    if (!success)
                        return MapError(Marshal.GetLastWin32Error());

                    return CaptureResult.Success;
                }
            }
            catch (ObjectDisposedException)
            {
                return CaptureResult.InvalidHandle;
            }
            finally
            {
                Interlocked.Decrement(ref _activeOperations);
            }
        }

        public void Shutdown()
        {
            // NOTE: Do NOT check _disposed here
            // Shutdown is a temporary pause operation, not final destruction
            // It must work even if the instance will be disposed later
            // This allows proper Start/Stop reentrancy as per rules v2 §71
            
            // Atomic shutdown flag - only one thread wins
            if (Interlocked.CompareExchange(ref _shutdownFlag, 1, 0) != 0)
                return;  // Already shutdown by another thread
            
            // Atomic swap: get handle and set to null in one operation
            WinDivertHandle? handle = Interlocked.Exchange(ref _handle, null);
            if (handle == null || handle.IsInvalid)
                return;

            // Shutdown reception first (unblocks WinDivertRecv calls)
            WinDivertShutdownNative(handle, ShutdownRecv);
            
            // Dispose handle (only this thread executes this)
            handle.Dispose();
        }

        public unsafe void CalculateChecksums(
            Span<byte> buffer,
            uint length,
            ref PacketMetadata metadata)
        {
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return;
            if (buffer.IsEmpty || length == 0)
                return;

            fixed (byte* pBuf = buffer)
            {
                WinDivertAddress addr = ToWinDivertAddress(ref metadata);
                WinDivertAddress* pAddr = &addr;

                WinDivertHelperCalcChecksumsNative(pBuf, length, pAddr, 0);
            }
        }

        public void Dispose()
		{
			if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 0)
			{
				// Wait for all active operations to complete before disposing
				// Uses SpinWait instead of locks (hot-path requirement)
				var spin = new System.Threading.SpinWait();
				while (Interlocked.CompareExchange(ref _activeOperations, 0, 0) != 0)
				{
					spin.SpinOnce();
					if (spin.Count > 10000)  // Timeout after ~10ms
						break;  // Force disposal if operations stuck
				}
				
				if (_handle != null && !_handle.IsInvalid)
				{
					// Shutdown orderly antes de cerrar handle (recv + send)
					WinDivertShutdownNative(_handle, NativeMethods.WinDivertShutdownBoth);
					_handle.Dispose();
				}
			}
		}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private CaptureResult ValidateHandle(out WinDivertHandle? handle)
        {
            handle = null;
            
            if (Interlocked.CompareExchange(ref _disposed, 0, 0) == 1)
                return CaptureResult.InvalidHandle;

            handle = _handle;
            if (handle == null || handle.IsInvalid)
                return CaptureResult.InvalidHandle;

            return CaptureResult.Success;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static CaptureResult MapError(int code)
        {
            return code switch
            {
                995 => CaptureResult.OperationAborted,
                6 => CaptureResult.InvalidHandle,
                87 => CaptureResult.InvalidParameter,
                1168 => CaptureResult.ElementNotFound,
                _ => CaptureResult.Unknown
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe uint ParsePacketLength(byte* pPacket, uint offset, uint readLen)
        {
            if (offset >= readLen)
                return 0;

            byte* pPkt = pPacket + offset;
            byte versionIHL = pPkt[0];
            byte version = (byte)(versionIHL >> 4);

            return version switch
            {
                4 => ParseIPv4Length(pPkt),
                6 => ParseIPv6Length(pPkt),
                _ => 0
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe uint ParseIPv4Length(byte* pPacket)
        {
            return (uint)((pPacket[2] << 8) | pPacket[3]);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe uint ParseIPv6Length(byte* pPacket)
        {
            uint payloadLen = (uint)((pPacket[4] << 8) | pPacket[5]);
            return 40 + payloadLen;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static WinDivertAddress ToWinDivertAddress(ref PacketMetadata metadata)
        {
            return new WinDivertAddress
            {
                Timestamp = metadata.Timestamp,
                IfIdx = metadata.InterfaceIndex,
                SubIfIdx = metadata.SubInterfaceIndex,
                Direction = metadata.Direction,
                Loopback = metadata.Loopback,
                Impostor = metadata.Impostor,
                IPChecksum = metadata.IpChecksum,
                TCPChecksum = metadata.TcpChecksum,
                UDPChecksum = metadata.UdpChecksum,
                Reserved1 = metadata.Reserved1,
                Reserved2 = metadata.Reserved2
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static PacketMetadata FromWinDivertAddress(ref WinDivertAddress addr)
        {
            return new PacketMetadata
            {
                Timestamp = addr.Timestamp,
                InterfaceIndex = addr.IfIdx,
                SubInterfaceIndex = addr.SubIfIdx,
                Direction = addr.Direction,
                Loopback = addr.Loopback,
                Impostor = addr.Impostor,
                IpChecksum = addr.IPChecksum,
                TcpChecksum = addr.TCPChecksum,
                UdpChecksum = addr.UDPChecksum,
                Reserved1 = addr.Reserved1,
                Reserved2 = addr.Reserved2
            };
        }

        [Conditional("DEBUG")]
        private static void ValidateStructLayout()
        {
            Debug.Assert(Marshal.SizeOf<WinDivertAddress>() == 28,
                "WinDivertAddress size mismatch - expected 28 bytes");
            Debug.Assert(Marshal.OffsetOf<WinDivertAddress>(nameof(WinDivertAddress.Timestamp)).ToInt32() == 0,
                "WinDivertAddress.Timestamp offset incorrect");
            Debug.Assert(Marshal.OffsetOf<WinDivertAddress>(nameof(WinDivertAddress.IfIdx)).ToInt32() == 8,
                "WinDivertAddress.IfIdx offset incorrect");
        }

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertOpen", StringMarshalling = StringMarshalling.Utf8)]
        private static partial WinDivertHandle WinDivertOpenNative(
            string filter,
            int layer,
            short priority,
            ulong flags);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertRecv")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static unsafe partial bool WinDivertRecvNative(
            WinDivertHandle handle,
            byte* pPacket,
            uint packetLen,
            out uint readLen,
            WinDivertAddress* pAddr);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertRecvEx")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static unsafe partial bool WinDivertRecvExNative(
            WinDivertHandle handle,
            byte* pPacket,
            uint packetLen,
            uint* pRecvLen,      // ← CORRECTED: was ulong*, should be uint*
            ulong flags,
            WinDivertAddress* pAddr,
            uint* pAddrLen,      // ← CORRECTED: Input/Output, size in BYTES (not element count)
            void* pOverlapped);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertSend")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static unsafe partial bool WinDivertSendNative(
            WinDivertHandle handle,
            byte* pPacket,
            uint packetLen,
            out uint writeLen,
            WinDivertAddress* pAddr);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertShutdown")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static partial bool WinDivertShutdownNative(
            WinDivertHandle handle,
            int how);

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertHelperCalcChecksums")]
        private static unsafe partial void WinDivertHelperCalcChecksumsNative(
            byte* pPacket,
            uint packetLen,
            WinDivertAddress* pAddr,
            ulong flags);
    }
}
]]>
</file>
<file path="NetShaper.Native\WinDivertAddress.cs">
<![CDATA[
// NetShaper.Native/WinDivertAddress.cs
using System.Runtime.InteropServices;

namespace NetShaper.Native
{
    /// <summary>
    /// Internal WinDivert address structure.
    /// This is an implementation detail specific to WinDivert and should not leak to abstractions.
    /// Layout matches WINDIVERT_ADDRESS (WinDivert 2.2).
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    internal struct WinDivertAddress
    {
        public long Timestamp;
        public uint IfIdx;
        public uint SubIfIdx;
        public byte Direction;
        public byte Loopback;
        public byte Impostor;
        public byte IPChecksum;
        public byte TCPChecksum;
        public byte UDPChecksum;
        public ushort Reserved1;
        public uint Reserved2;
    }
}

]]>
</file>
<file path="NetShaper.Native\WinDivertHandle.cs">
<![CDATA[
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;

namespace NetShaper.Native
{
    public sealed partial class WinDivertHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        public WinDivertHandle() : base(true) { }

        protected override bool ReleaseHandle()
        {
            return WinDivertClose(handle);
        }

        [LibraryImport("WinDivert.dll", EntryPoint = "WinDivertClose", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static partial bool WinDivertClose(IntPtr handle);
    }

    // WinDivertAddress movido a NetShaper.Abstractions
}
]]>
</file>
<file path="NetShaper.Normative\NetShaperNormativeAnalyzer.cs">
<![CDATA[
using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Operations;

namespace NetShaper.Analyzers
{
    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    public sealed class NetShaperNormativeAnalyzer : DiagnosticAnalyzer
    {
        #region Rules
        private static readonly DiagnosticDescriptor UnsafeWithoutFixed = new("RED_R5_03A", "unsafe sin fixed en Engine", "Bloque unsafe en NetShaper.Engine debe contener fixed", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor DomainExceptionInEngine = new("RED_R6_10", "DomainException prohibida en Engine", "No se permite DomainException en NetShaper.Engine", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor UseCaseComplexityExceeded = new("DR07", "Complejidad ciclomática excedida", "[UseCase] no puede tener complejidad ciclomática > 5", "NetShaper.Domain", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor MissingInvariantMethod = new("DR04", "Invariante no declarada", "Tipo de dominio debe declarar ValidateInvariant / TryValidateInvariant", "NetShaper.Domain", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor MutableValueObject = new("DR02", "ValueObject mutable", "[ValueObject] debe ser inmutable", "NetShaper.Domain", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor InvalidDomainState = new("DR06", "Estado de dominio inválido", "[DomainState] debe ser enum", "NetShaper.Domain", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor GenericExceptionUsage = new("DR08", "Uso de Exception genérica", "Prohibido throw new System.Exception en dominio", "NetShaper.Domain", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor NoRegionsAllowed = new("R205", "Prohibido el uso de #region", "El uso de #region está prohibido", "Style", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor NoVolatileInEngine = new("R307", "Prohibido 'volatile' en Engine", "El modificador 'volatile' está prohibido en NetShaper.Engine", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor UseLibraryImport = new("R502", "P/Invoke debe usar LibraryImport", "Reemplace [DllImport] con [LibraryImport]", "Security", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor NoBinaryFormatter = new("R505", "BinaryFormatter está prohibido", "BinaryFormatter es inseguro", "Security", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor PrivateFieldNaming = new("R701", "Campos privados deben usar _camelCase", "El campo privado '{0}' debe seguir el formato _camelCase", "Naming", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor EntityInEngineMustBeStruct = new("DR03", "Entity en Engine debe ser un struct", "Las entidades en NetShaper.Engine deben ser 'struct'", "NetShaper.Domain", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor DomainEventImmutable = new("DR09", "DomainEvent debe ser inmutable", "Los eventos de dominio deben ser inmutables", "NetShaper.Domain", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor AsyncInEngineProhibited = new("R301", "Prohibido async en Engine", "'async' está prohibido en NetShaper.Engine excepto en [EngineSetup]", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor LinqInHotPathProhibited = new("R303", "Prohibido LINQ en Hot-Path", "LINQ está prohibido en NetShaper.Engine", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor StringConcatInLoopProhibited = new("R311", "Prohibida la concatenación de strings en bucles", "Use StringBuilder para concatenar strings dentro de bucles", "Performance", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor ToArrayToListInEngineProhibited = new("R403", "Prohibido ToArray/ToList en Engine", "ToArray/ToList está prohibido en NetShaper.Engine", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor ExplicitGcCollectProhibited = new("R1101", "Prohibido GC.Collect explícito", "Llamadas explícitas a GC.Collect() están prohibidas", "Performance", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor ThreadSleepInUiProhibited = new("R1201", "Prohibido Thread.Sleep en UI", "Thread.Sleep bloquea el hilo UI. Use await Task.Delay() en su lugar.", "UI", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor MissingCancellationToken = new("R312", "Falta CancellationToken en método async", "Los métodos asíncronos deben aceptar un CancellationToken", "Correctness", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor MissingAsyncSuffix = new("R704", "Falta sufijo 'Async' en método asíncrono", "El método asíncrono '{0}' debe terminar con el sufijo 'Async'", "Naming", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor DisposableFieldNeedsDisposing = new("R902", "Campo IDisposable requiere que la clase implemente IDisposable", "La clase '{0}' tiene campos IDisposable y debe implementar IDisposable", "Resource Management", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor AsyncVoidIsForEventHandlersOnly = new("R1202", "'async void' solo para manejadores de eventos", "Use 'async Task' en lugar de 'async void' fuera de manejadores de eventos", "Correctness", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor EmptyCatchBlockProhibited = new("R603", "Prohibido bloque catch vacío", "Los bloques catch no deben estar vacíos", "Correctness", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor NoTodos = new("R206", "Comentario TODO/FIXME/HACK encontrado", "Se encontró un comentario '{0}'. Resuelva la tarea pendiente.", "Code Quality", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor ConstructorDependencyLimit = new("R103", "Límite de dependencias de constructor excedido", "El constructor tiene demasiados parámetros ({0}). El límite es 4.", "Architecture", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor CyclomaticComplexityExceeded = new("R201", "Complejidad ciclomática excedida", "La complejidad ciclomática de '{0}' es {1}, que excede el límite de {2}", "Complexity", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor OneClassPerFile = new("R204", "Un tipo público por archivo", "El archivo contiene más de un tipo público", "Style", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor BoxingInEngine = new("R304", "Boxing allocation detectado en Engine", "La conversión de '{0}' a '{1}' causa una asignación de memoria (boxing) en un hot-path", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor LockInEngineProhibited = new("R306", "Lock prohibido en Engine", "El uso de 'lock' está prohibido en NetShaper.Engine. Use mecanismos sin bloqueo.", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor PascalCaseNaming = new("R702", "Propiedades y métodos públicos deben usar PascalCase", "El miembro público '{0}' debe usar PascalCase", "Naming", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor MagicNumberProhibited = new("R1203", "Número mágico encontrado", "El número '{0}' es un número mágico. Use constantes con nombres descriptivos.", "Code Quality", DiagnosticSeverity.Warning, true);
        
        // FASE 1+2: Nuevas reglas críticas
        private static readonly DiagnosticDescriptor TaskInEngineProhibited = new("R302", "Prohibido Task en Engine", "El uso de Task está prohibido en NetShaper.Engine excepto en [EngineSetup]", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor DateTimeInEngineProhibited = new("R305", "Prohibido DateTime en Engine", "Use Stopwatch.GetTimestamp() en lugar de DateTime.Now/UtcNow o Environment.TickCount", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor ExceptionsAsControlFlow = new("R308", "Exceptions como control de flujo", "try-catch en un loop o catch(Exception) fuera de boundaries está prohibido", "Correctness", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor ArrayPoolRequired = new("R309", "ArrayPool obligatorio en Engine", "Use ArrayPool<byte>.Shared.Rent() en lugar de new byte[] (excepto arrays ≤16)", "NetShaper.Engine", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor SpanMemoryPreferred = new("R310", "Preferir Span/Memory", "Use ReadOnlySpan<byte> o Memory<byte> en lugar de byte[] como parámetro público", "NetShaper.Engine", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor ArrayPoolOwnership = new("R401", "Ownership ArrayPool desbalanceado", "Cada Rent() debe tener su Return() correspondiente (o marcar método con [BufferOwner])", "Memory", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor BufferSizeNonStandard = new("R402", "Tamaño de buffer no estándar", "Use tamaños estándar: 1500, 2048, 4096, 8192, 65536 o constantes nombradas", "Memory", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor StructuredLoggingRequired = new("R601", "Logging estructurado requerido", "En NetShaper.Engine use structs para logging, no strings", "Logging", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor CatchExceptionOnlyBoundaries = new("R602", "catch(Exception) solo en boundaries", "catch(Exception) solo permitido en Main, [Boundary], Controllers", "Correctness", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor DisposableWithoutUsing = new("R901", "IDisposable sin using", "Las variables IDisposable deben usarse con 'using' o llamar .Dispose()", "Resource Management", DiagnosticSeverity.Error, true);
        
        // FASES 3-5: Reglas adicionales críticas
        private static readonly DiagnosticDescriptor CyclomaticComplexityUiInfra = new("R202", "Complejidad cicl omática UI/Infra excedida", "La complejidad cicl omática de '{0}' es {1}, que excede el límite de 10", "Complexity", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor NestingDepthExceeded = new("R203", "Anidación máxima excedida", "El método '{0}' tiene anidación de {1} niveles, que excede el límite de {2}", "Complexity", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor StructuredLoggingRecommended = new("R604", "Use logging estructurado", "Preferir placeholders {{name}} en lugar de string literals en logs", "Logging", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor SafeHandleRequired = new("R501", "SafeHandle requerido para IntPtr", "Los métodos P/Invoke que retornan IntPtr deben usar SafeHandle", "Security", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor FixedOnlyInEngineNative = new("R504", "fixed solo en Engine/Native", "El statement 'fixed' solo está permitido en NetShaper.Engine y NetShaper.Native", "Security", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor HardcodedSecretDetected = new("R506", "Posible secret hardcoded", "Posible secret/password/key detectado en código fuente", "Security", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor MissingInputValidation = new("R507", "Falta validación de input", "Parámetros reference types deben validarse con guard clauses", "Security", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor NullableNotEnabled = new("R801", "Nullable no habilitado", "El proyecto debe tener Nullable habilitado globalmente", "Nullability", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor NullableParameterInPublicApi = new("R802", "Parámetro nullable en API pública", "Los parámetros de APIs públicas no deben ser nullable", "Nullability", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor WarningsNotAsErrors = new("R803", "Warnings no configurados como errors", "TreatWarningsAsErrors debe estar habilitado en .csproj", "Code Quality", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor RedundantThis = new("R705", "'this.' redundante", "El uso de 'this.' es redundante (no hay shadowing)", "Style", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor VarPreferred = new("R706", "Preferir 'var' para tipos evidentes", "Use 'var' cuando el tipo es evidente (new T(), cast explícito)", "Style", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor MissingDomainAttribute = new("DR01", "Falta atributo de dominio", "Las clases en namespace Domain deben tener [Entity], [ValueObject], [AggregateRoot], [DomainEvent] o [UseCase]", "NetShaper.Domain", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor ThrowInTechnicalDomain = new("DR05", "throw prohibido en dominio técnico", "Los statements 'throw' están prohibidos en NetShaper.Engine/Native (excepto [EngineSetup]/[Boundary])", "NetShaper.Domain", DiagnosticSeverity.Error, true);
        
        // Reglas adicionales
        private static readonly DiagnosticDescriptor MemberOrderViolation = new("R707", "Orden de miembros incorrecto", "El miembro '{0}' está fuera de orden. Orden esperado: const, static fields, fields, static ctor, ctor, props, methods", "Style", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor DINotViaConstructor = new("R1402", "Dependencias no inyectadas por constructor", "La clase '{0}' tiene dependencias que no se inyectan por constructor (evitar service locator)", "Architecture", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor MissingInvariantTests = new("DR10", "Faltan tests de invariantes", "El tipo de dominio '{0}' debe tener tests que validen sus invariantes", "NetShaper.Domain", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor TransactionalEventsInEngine = new("R1020", "Eventos transaccionales en Engine", "Los eventos en Engine no deben requerir transacciones (diseño no transaccional)", "NetShaper.Engine", DiagnosticSeverity.Warning, true);
        
        // Reglas final batch
        private static readonly DiagnosticDescriptor AbstractionsWithDependencies = new("R104", "Abstractions tiene dependencias", "NetShaper.Abstractions no debe depender de otros proyectos NetShaper (excepto System.*)", "Architecture", DiagnosticSeverity.Error, true);
        private static readonly DiagnosticDescriptor LowCohesion = new("R207", "Baja cohesión detectada", "La clase '{0}' tiene baja cohesión (campos/métodos no relacionados). Considerar dividir.", "Complexity", DiagnosticSeverity.Warning, true);
        private static readonly DiagnosticDescriptor GCCollectWithSuppression = new("R1101B", "GC.Collect con suppressión incorrecta", "GC.Collect debe usarse con GC.WaitForPendingFinalizers() o está prohibido", "Performance", DiagnosticSeverity.Warning, true);
        #endregion

        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics =>
            ImmutableArray.Create(UnsafeWithoutFixed, DomainExceptionInEngine, UseCaseComplexityExceeded, MissingInvariantMethod, MutableValueObject, InvalidDomainState, GenericExceptionUsage, 
                NoRegionsAllowed, NoVolatileInEngine, UseLibraryImport, NoBinaryFormatter, PrivateFieldNaming, EntityInEngineMustBeStruct, DomainEventImmutable,
                AsyncInEngineProhibited, LinqInHotPathProhibited, StringConcatInLoopProhibited, ToArrayToListInEngineProhibited, ExplicitGcCollectProhibited, ThreadSleepInUiProhibited,
                MissingCancellationToken, MissingAsyncSuffix, DisposableFieldNeedsDisposing, AsyncVoidIsForEventHandlersOnly, EmptyCatchBlockProhibited, NoTodos,
                ConstructorDependencyLimit, CyclomaticComplexityExceeded, OneClassPerFile, BoxingInEngine, LockInEngineProhibited, PascalCaseNaming, MagicNumberProhibited,
                // FASE 1+2: Nuevas reglas
                TaskInEngineProhibited, DateTimeInEngineProhibited, ExceptionsAsControlFlow, ArrayPoolRequired, SpanMemoryPreferred,
                ArrayPoolOwnership, BufferSizeNonStandard, StructuredLoggingRequired, CatchExceptionOnlyBoundaries, DisposableWithoutUsing,
                // FASES 3-5: Reglas adicionales
                CyclomaticComplexityUiInfra, NestingDepthExceeded, StructuredLoggingRecommended, SafeHandleRequired, FixedOnlyInEngineNative,
                HardcodedSecretDetected, MissingInputValidation, NullableNotEnabled, NullableParameterInPublicApi, WarningsNotAsErrors,
                RedundantThis, VarPreferred, MissingDomainAttribute, ThrowInTechnicalDomain,
                // Reglas adicionales
                MemberOrderViolation, DINotViaConstructor, MissingInvariantTests, TransactionalEventsInEngine,
                // Reglas final batch
                AbstractionsWithDependencies, LowCohesion, GCCollectWithSuppression);

        public override void Initialize(AnalysisContext context)
        {
            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
            context.EnableConcurrentExecution();

            context.RegisterSymbolAction(AnalyzeNamedType, SymbolKind.NamedType);
            context.RegisterSymbolAction(AnalyzeMethod, SymbolKind.Method);
            context.RegisterSymbolAction(AnalyzeProperty, SymbolKind.Property);
            context.RegisterSymbolAction(AnalyzeField, SymbolKind.Field);
            context.RegisterSyntaxNodeAction(AnalyzeUnsafeBlock, SyntaxKind.UnsafeStatement);
            context.RegisterSyntaxNodeAction(AnalyzeThrow, SyntaxKind.ThrowStatement);
            context.RegisterSyntaxNodeAction(AnalyzeDllImport, SyntaxKind.Attribute);
            context.RegisterSyntaxNodeAction(AnalyzeInvocation, SyntaxKind.InvocationExpression);
            context.RegisterSyntaxNodeAction(AnalyzeStringConcatInLoop, SyntaxKind.AddExpression);
            context.RegisterSyntaxNodeAction(AnalyzeEmptyCatch, SyntaxKind.CatchClause);
            context.RegisterSyntaxNodeAction(AnalyzeLockStatement, SyntaxKind.LockStatement);
            context.RegisterSyntaxNodeAction(AnalyzeLiterals, SyntaxKind.NumericLiteralExpression);
            context.RegisterSyntaxTreeAction(AnalyzeOneClassPerFile);
            context.RegisterSyntaxTreeAction(AnalyzeTodos);
            context.RegisterOperationAction(AnalyzeBoxingConversion, OperationKind.Conversion);
            
            // FASE 1+2: Nuevos registros
            context.RegisterSyntaxNodeAction(AnalyzeTaskUsage, SyntaxKind.IdentifierName);
            context.RegisterSyntaxNodeAction(AnalyzeDateTimeUsage, SyntaxKind.SimpleMemberAccessExpression);
            context.RegisterSyntaxNodeAction(AnalyzeExceptionControlFlow, SyntaxKind.TryStatement);
            context.RegisterSyntaxNodeAction(AnalyzeArrayCreationForPool, SyntaxKind.ArrayCreationExpression);
            context.RegisterSyntaxNodeAction(AnalyzeArrayPoolBufferSize, SyntaxKind.InvocationExpression);
            context.RegisterSyntaxNodeAction(AnalyzeEngineLogging, SyntaxKind.InvocationExpression);
            context.RegisterSyntaxNodeAction(AnalyzeCatchExceptionBoundary, SyntaxKind.CatchClause);
            context.RegisterSyntaxNodeAction(AnalyzeDisposableVariable, SyntaxKind.VariableDeclarator);
            
            // FASES 3-5: Nuevos registros
            context.RegisterSyntaxNodeAction(AnalyzeFixedStatement, SyntaxKind.FixedStatement);
            context.RegisterSyntaxNodeAction(AnalyzeHardcodedSecrets, SyntaxKind.StringLiteralExpression);
            context.RegisterSyntaxNodeAction(AnalyzeRedundantThis, SyntaxKind.SimpleMemberAccessExpression);
            context.RegisterSyntaxNodeAction(AnalyzeVarUsage, SyntaxKind.VariableDeclaration);
            context.RegisterSyntaxNodeAction(AnalyzeThrowInTechnicalDomain, SyntaxKind.ThrowStatement);
            context.RegisterSyntaxNodeAction(AnalyzeStructuredLoggingRecommended, SyntaxKind.InvocationExpression);
            context.RegisterSyntaxNodeAction(AnalyzeGCCollectPattern, SyntaxKind.InvocationExpression);
        }

        #region Analyzers

        private static void AnalyzeBoxingConversion(OperationAnalysisContext context)
        {
            var conversionOperation = (IConversionOperation)context.Operation;
            var fromType = conversionOperation.Operand.Type;
            var toType = conversionOperation.Type;

            if (fromType == null || toType == null) return;

            bool isBoxing = fromType.IsValueType && (toType.SpecialType == SpecialType.System_Object || toType.TypeKind == TypeKind.Interface);
            if (!isBoxing) return;

            var isInEngine = context.Operation.Syntax.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.Engine") ?? false;
            if (!isInEngine) return;

            context.ReportDiagnostic(Diagnostic.Create(BoxingInEngine, context.Operation.Syntax.GetLocation(), fromType.ToDisplayString(), toType.ToDisplayString()));
        }

        private static void AnalyzeNamedType(SymbolAnalysisContext context)
        {
            if (context.Symbol is not INamedTypeSymbol type) return;

            AnalyzeDomainType(context, type);
            AnalyzeEntityInEngine(context, type);
            AnalyzeDomainEventImmutability(context, type);
            AnalyzeForBinaryFormatter(context, type);
            AnalyzeDisposableFields(context, type);
            
            // FASES 3-5
            AnalyzeDomainAttribute(context, type);
            
            // Reglas adicionales
            AnalyzeMemberOrder(context, type);
            AnalyzeDIViaConstructor(context, type);
            AnalyzeInvariantTests(context, type);
            AnalyzeTransactionalEvents(context, type);
            
            // Final batch
            AnalyzeAbstractionsDependencies(context, type);
            AnalyzeLowCohesion(context, type);
        }
        
        private static void AnalyzeField(SymbolAnalysisContext context) 
        {
            if (context.Symbol is not IFieldSymbol field) return;

            if (field.IsConst || field.IsImplicitlyDeclared || field.DeclaredAccessibility != Accessibility.Private) return;

            if (!field.Name.StartsWith("_"))
            {
                context.ReportDiagnostic(Diagnostic.Create(PrivateFieldNaming, field.Locations[0], field.Name));
            }

            AnalyzeVolatileInEngine(context, field);
        }
        
        private static void AnalyzeUnsafeBlock(SyntaxNodeAnalysisContext context)
        {
            var unsafeBlock = (UnsafeStatementSyntax)context.Node;
            
            var isInEngine = unsafeBlock.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.Engine") ?? false;
            if (!isInEngine) return;

            // Verificar si contiene fixed statement
            bool hasFixed = unsafeBlock.DescendantNodes().OfType<FixedStatementSyntax>().Any();
            if (!hasFixed)
            {
                context.ReportDiagnostic(Diagnostic.Create(UnsafeWithoutFixed, unsafeBlock.GetLocation()));
            }
        }

        private static void AnalyzeThrow(SyntaxNodeAnalysisContext context)
        {
            var throwStatement = (ThrowStatementSyntax)context.Node;
            if (throwStatement.Expression is not ObjectCreationExpressionSyntax creation) return;

            var symbolInfo = context.SemanticModel.GetSymbolInfo(creation.Type);
            var typeSymbol = symbolInfo.Symbol as INamedTypeSymbol;
            if (typeSymbol == null) return;

            var typeName = typeSymbol.ToDisplayString();

            // DR08: Prohibido System.Exception genérico
            if (typeName == "System.Exception")
            {
                context.ReportDiagnostic(Diagnostic.Create(GenericExceptionUsage, throwStatement.GetLocation()));
            }

            // RED_R6_10: DomainException prohibida en Engine
            if (typeName.Contains("DomainException"))
            {
                var isInEngine = throwStatement.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.Engine") ?? false;
                if (isInEngine)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DomainExceptionInEngine, throwStatement.GetLocation()));
                }
            }
        }

        private static void AnalyzeDllImport(SyntaxNodeAnalysisContext context)
        {
            var attribute = (AttributeSyntax)context.Node;
            var name = attribute.Name.ToString();
            
            if (name == "DllImport" || name == "DllImportAttribute")
            {
                context.ReportDiagnostic(Diagnostic.Create(UseLibraryImport, attribute.GetLocation()));
            }
        }

        private static void AnalyzeInvocation(SyntaxNodeAnalysisContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;
            var symbolInfo = context.SemanticModel.GetSymbolInfo(invocation);
            var method = symbolInfo.Symbol as IMethodSymbol;
            if (method == null) return;

            var methodName = method.Name;
            var containingType = method.ContainingType?.ToDisplayString() ?? "";

            var isInEngine = invocation.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.Engine") ?? false;

            // R303: LINQ prohibido en Engine
            if (isInEngine)
            {
                var linqMethods = new[] { "Where", "Select", "SelectMany", "OrderBy", "OrderByDescending", "GroupBy", 
                                         "Join", "Any", "All", "First", "FirstOrDefault", "Single", "SingleOrDefault",
                                         "Last", "LastOrDefault", "Count", "Sum", "Average", "Min", "Max", "Aggregate" };
                
                if (linqMethods.Contains(methodName) && containingType.StartsWith("System.Linq"))
                {
                    context.ReportDiagnostic(Diagnostic.Create(LinqInHotPathProhibited, invocation.GetLocation()));
                }

                // R403: ToArray/ToList prohibido en Engine
                if (methodName == "ToArray" || methodName == "ToList")
                {
                    context.ReportDiagnostic(Diagnostic.Create(ToArrayToListInEngineProhibited, invocation.GetLocation()));
                }
            }

            // R1101: GC.Collect prohibido
            if (containingType == "System.GC" && methodName == "Collect")
            {
                context.ReportDiagnostic(Diagnostic.Create(ExplicitGcCollectProhibited, invocation.GetLocation()));
            }

            // R1201: Thread.Sleep en UI
            if (containingType == "System.Threading.Thread" && methodName == "Sleep")
            {
                var isInUi = invocation.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.UI") ?? false;
                if (isInUi)
                {
                    context.ReportDiagnostic(Diagnostic.Create(ThreadSleepInUiProhibited, invocation.GetLocation()));
                }
            }
        }

        private static void AnalyzeStringConcatInLoop(SyntaxNodeAnalysisContext context)
        {
            var addExpression = (BinaryExpressionSyntax)context.Node;
            
            // Verificar si es concatenación de strings
            var typeInfo = context.SemanticModel.GetTypeInfo(addExpression);
            if (typeInfo.Type?.SpecialType != SpecialType.System_String) return;

            // Verificar si está dentro de un loop
            var isInLoop = addExpression.Ancestors().Any(n => 
                n is ForStatementSyntax || 
                n is ForEachStatementSyntax || 
                n is WhileStatementSyntax || 
                n is DoStatementSyntax);

            if (isInLoop)
            {
                context.ReportDiagnostic(Diagnostic.Create(StringConcatInLoopProhibited, addExpression.GetLocation()));
            }
        }

        private static void AnalyzeEmptyCatch(SyntaxNodeAnalysisContext context)
        {
            var catchClause = (CatchClauseSyntax)context.Node;
            
            // Verificar si el bloque está vacío
            var block = catchClause.Block;
            if (block.Statements.Count == 0 && block.DescendantTrivia().All(t => t.IsKind(SyntaxKind.WhitespaceTrivia) || t.IsKind(SyntaxKind.EndOfLineTrivia)))
            {
                context.ReportDiagnostic(Diagnostic.Create(EmptyCatchBlockProhibited, catchClause.GetLocation()));
            }
        }

        private static void AnalyzeTodos(SyntaxTreeAnalysisContext context)
        {
            foreach (var trivia in context.Tree.GetRoot().DescendantTrivia())
            {
                if (!trivia.IsKind(SyntaxKind.SingleLineCommentTrivia) && !trivia.IsKind(SyntaxKind.MultiLineCommentTrivia))
                    continue;

                var text = trivia.ToString();
                var keywords = new[] { "TODO", "FIXME", "HACK" };
                
                foreach (var keyword in keywords)
                {
                    if (text.IndexOf(keyword, StringComparison.OrdinalIgnoreCase) >= 0)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(NoTodos, trivia.GetLocation(), keyword));
                        break;
                    }
                }
            }
        }

        private static void AnalyzeDomainType(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            var attributes = type.GetAttributes();
            var domainAttributes = new[] { "EntityAttribute", "ValueObjectAttribute", "AggregateRootAttribute" };
            
            var hasDomainAttribute = attributes.Any(a => domainAttributes.Contains(a.AttributeClass?.Name));
            if (!hasDomainAttribute) return;

            // DR04: Verificar ValidateInvariant
            var hasValidateInvariant = type.GetMembers().OfType<IMethodSymbol>()
                .Any(m => m.Name == "ValidateInvariant" || m.Name == "TryValidateInvariant");

            if (!hasValidateInvariant)
            {
                context.ReportDiagnostic(Diagnostic.Create(MissingInvariantMethod, type.Locations[0]));
            }

            // DR02: ValueObject debe ser inmutable
            var isValueObject = attributes.Any(a => a.AttributeClass?.Name == "ValueObjectAttribute");
            if (isValueObject)
            {
                var hasSettableProperties = type.GetMembers().OfType<IPropertySymbol>()
                    .Any(p => p.SetMethod != null && p.SetMethod.DeclaredAccessibility == Accessibility.Public);

                var hasPublicFields = type.GetMembers().OfType<IFieldSymbol>()
                    .Any(f => f.DeclaredAccessibility == Accessibility.Public && !f.IsReadOnly && !f.IsConst);

                if (hasSettableProperties || hasPublicFields)
                {
                    context.ReportDiagnostic(Diagnostic.Create(MutableValueObject, type.Locations[0]));
                }
            }
        }

        private static void AnalyzeEntityInEngine(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            var isEntity = type.GetAttributes().Any(a => a.AttributeClass?.Name == "EntityAttribute");
            if (!isEntity) return;

            var nsName = type.ContainingNamespace?.ToDisplayString() ?? "";
            if (!nsName.StartsWith("NetShaper.Engine")) return;

            // DR03: Entity en Engine debe ser struct
            if (type.TypeKind != TypeKind.Struct)
            {
                context.ReportDiagnostic(Diagnostic.Create(EntityInEngineMustBeStruct, type.Locations[0]));
            }
        }

        private static void AnalyzeDomainEventImmutability(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            var isDomainEvent = type.GetAttributes().Any(a => a.AttributeClass?.Name == "DomainEventAttribute");
            if (!isDomainEvent) return;

            // DR09: DomainEvent debe ser inmutable
            bool isImmutable = true;

            // Verificar si es record (inmutable por defecto)
            if (type.IsRecord && type.TypeKind == TypeKind.Class)
            {
                // Records con init-only properties son inmutables
                isImmutable = true;
            }
            else if (type.TypeKind == TypeKind.Struct)
            {
                // Verificar readonly struct
                if (!type.IsReadOnly)
                {
                    isImmutable = false;
                }
            }
            else
            {
                // Class regular: verificar properties settables
                var hasSettableProperties = type.GetMembers().OfType<IPropertySymbol>()
                    .Any(p => p.SetMethod != null && p.SetMethod.DeclaredAccessibility != Accessibility.Private);

                if (hasSettableProperties)
                {
                    isImmutable = false;
                }
            }

            if (!isImmutable)
            {
                context.ReportDiagnostic(Diagnostic.Create(DomainEventImmutable, type.Locations[0]));
            }
        }

        private static void AnalyzeForBinaryFormatter(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            // R505: BinaryFormatter prohibido
            var usesFormatter = type.GetMembers().OfType<IMethodSymbol>().Any(m =>
            {
                if (m.DeclaringSyntaxReferences.Length == 0) return false;
                var syntax = m.DeclaringSyntaxReferences[0].GetSyntax();
                var text = syntax.ToString();
                return text.Contains("BinaryFormatter");
            });

            if (usesFormatter)
            {
                context.ReportDiagnostic(Diagnostic.Create(NoBinaryFormatter, type.Locations[0]));
            }
        }

        private static void AnalyzeUseCaseComplexity(SymbolAnalysisContext context, IMethodSymbol method)
        {
            var isUseCase = method.ContainingType.GetAttributes().Any(a => a.AttributeClass?.Name == "UseCaseAttribute");
            if (!isUseCase) return;

            if (method.DeclaringSyntaxReferences.Length == 0) return;
            var syntax = method.DeclaringSyntaxReferences[0].GetSyntax();
            var complexity = CalculateCyclomaticComplexity(syntax);

            // DR07: UseCase CC > 5
            if (complexity > 5)
            {
                context.ReportDiagnostic(Diagnostic.Create(UseCaseComplexityExceeded, method.Locations[0]));
            }
        }

        private static void AnalyzeAsyncInEngine(SymbolAnalysisContext context, IMethodSymbol method)
        {
            if (!method.IsAsync) return;
            
            var nsName = method.ContainingNamespace?.ToDisplayString() ?? "";
            if (!nsName.StartsWith("NetShaper.Engine")) return;
            
            if (method.GetAttributes().Any(a => a.AttributeClass?.Name == "EngineSetupAttribute"))
                return;
            
            context.ReportDiagnostic(Diagnostic.Create(AsyncInEngineProhibited, method.Locations[0]));
        }

        private static void AnalyzeVolatileInEngine(SymbolAnalysisContext context, IFieldSymbol field)
        {
            if (!field.IsVolatile) return;

            var nsName = field.ContainingNamespace?.ToDisplayString() ?? "";
            if (nsName.StartsWith("NetShaper.Engine"))
            {
                context.ReportDiagnostic(Diagnostic.Create(NoVolatileInEngine, field.Locations[0]));
            }
        }

        private static void AnalyzeAsyncNamingAndSignature(SymbolAnalysisContext context, IMethodSymbol method)
        {
            if (!method.IsAsync) return;

            // R704: Async suffix
            if (!method.Name.EndsWith("Async") && method.MethodKind != MethodKind.Constructor)
            {
                context.ReportDiagnostic(Diagnostic.Create(MissingAsyncSuffix, method.Locations[0], method.Name));
            }

            // R1202: async void solo para event handlers
            if (method.ReturnsVoid)
            {
                // Verificar si es event handler por naming convention
                bool isEventHandler = method.Parameters.Length == 2 && 
                                     method.Parameters[0].Type.SpecialType == SpecialType.System_Object &&
                                     method.Parameters[1].Type.Name.EndsWith("EventArgs");
                
                if (!isEventHandler)
                {
                    context.ReportDiagnostic(Diagnostic.Create(AsyncVoidIsForEventHandlersOnly, method.Locations[0]));
                }
            }

            // R312: CancellationToken requerido
            // Skip event handlers (verificados arriba)
            bool isEventHandlerMethod = method.Parameters.Length == 2 && 
                                 method.Parameters[0].Type.SpecialType == SpecialType.System_Object &&
                                 method.Parameters[1].Type.Name.EndsWith("EventArgs");
            
            if (!isEventHandlerMethod)
            {
                var hasCancellationToken = method.Parameters.Any(p => p.Type.Name == "CancellationToken");
                if (!hasCancellationToken && method.DeclaredAccessibility == Accessibility.Public)
                {
                    context.ReportDiagnostic(Diagnostic.Create(MissingCancellationToken, method.Locations[0]));
                }
            }
        }

        private static void AnalyzeDisposableFields(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            var disposableFields = type.GetMembers().OfType<IFieldSymbol>()
                .Where(f => f.Type.AllInterfaces.Any(i => i.Name == "IDisposable"))
                .ToList();

            if (disposableFields.Count == 0) return;

            var implementsIDisposable = type.AllInterfaces.Any(i => i.Name == "IDisposable");
            if (!implementsIDisposable)
            {
                context.ReportDiagnostic(Diagnostic.Create(DisposableFieldNeedsDisposing, type.Locations[0], type.Name));
            }
        }

        private static void AnalyzeMethod(SymbolAnalysisContext context) 
        {
            if (context.Symbol is not IMethodSymbol method) return;
            AnalyzeCyclomaticComplexity(context, method);
            AnalyzeAsyncInEngine(context, method);
            AnalyzeAsyncNamingAndSignature(context, method);
            AnalyzePascalCase(context, method);
            AnalyzeUseCaseComplexity(context, method);
            
            // FASE 1+2
            AnalyzeByteArrayParameter(context, method);
            AnalyzeArrayPoolBalance(context, method);
            
            // FASES 3-5
            AnalyzeNestingDepth(context, method);
            AnalyzeSafeHandleRequired(context, method);
            AnalyzeInputValidation(context, method);
            AnalyzeNullableParameter(context, method);
            
            if (method.MethodKind == MethodKind.Constructor) AnalyzeConstructorDependencies(context, method);
        }

        private static void AnalyzeProperty(SymbolAnalysisContext context)
        {
            if (context.Symbol is not IPropertySymbol property) return;
            AnalyzePascalCase(context, property);
        }

        private static int CalculateCyclomaticComplexity(SyntaxNode node) => 
            node.DescendantNodes().Count(n => 
                n is IfStatementSyntax || 
                n is ForStatementSyntax || 
                n is ForEachStatementSyntax || 
                n is WhileStatementSyntax || 
                n is DoStatementSyntax || 
                n is CaseSwitchLabelSyntax || 
                n is ConditionalExpressionSyntax ||
                n is BinaryExpressionSyntax binary && (binary.IsKind(SyntaxKind.LogicalAndExpression) || binary.IsKind(SyntaxKind.LogicalOrExpression))
            ) + 1;

        private static void AnalyzeCyclomaticComplexity(SymbolAnalysisContext context, IMethodSymbol method)
        {
            if (method.DeclaringSyntaxReferences.Length == 0) return;
            var syntax = method.DeclaringSyntaxReferences[0].GetSyntax();
            var complexity = CalculateCyclomaticComplexity(syntax);

            var nsName = method.ContainingNamespace?.ToDisplayString() ?? "";
            int limit = 10; // Default

            if (nsName.StartsWith("NetShaper.Engine"))
            {
                limit = 7;
                // Verificar [ProtocolParser] para CC≤12
                if (method.GetAttributes().Any(a => a.AttributeClass?.Name == "ProtocolParserAttribute"))
                {
                    limit = 12;
                }
            }

            if (complexity > limit)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    CyclomaticComplexityExceeded, 
                    method.Locations[0], 
                    method.Name, 
                    complexity, 
                    limit
                ));
            }
        }

        private static void AnalyzeConstructorDependencies(SymbolAnalysisContext context, IMethodSymbol constructor)
        {
            var paramCount = constructor.Parameters.Length;
            const int limit = 4;

            // Excepto [CompositionRoot]
            if (constructor.ContainingType.GetAttributes().Any(a => a.AttributeClass?.Name == "CompositionRootAttribute"))
                return;

            if (paramCount > limit)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    ConstructorDependencyLimit, 
                    constructor.Locations[0], 
                    paramCount
                ));
            }
        }

        private static void AnalyzeOneClassPerFile(SyntaxTreeAnalysisContext context)
        {
            var root = context.Tree.GetRoot();
            var publicTypes = root.DescendantNodes()
                .OfType<TypeDeclarationSyntax>()
                .Where(t => t.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword)))
                .ToList();

            if (publicTypes.Count > 1)
            {
                foreach (var type in publicTypes.Skip(1))
                {
                    context.ReportDiagnostic(Diagnostic.Create(OneClassPerFile, type.Identifier.GetLocation()));
                }
            }
        }
        
        private static void AnalyzeLockStatement(SyntaxNodeAnalysisContext context)
        {
            var isInEngine = context.Node.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.Engine") ?? false;
            if (isInEngine)
            {
                context.ReportDiagnostic(Diagnostic.Create(LockInEngineProhibited, context.Node.GetLocation()));
            }
        }

        private static void AnalyzePascalCase(SymbolAnalysisContext context, ISymbol symbol)
        {
            if (symbol.DeclaredAccessibility != Accessibility.Public) return;
            
            if (symbol is IMethodSymbol method)
            {
                if (method.MethodKind == MethodKind.PropertyGet ||
                    method.MethodKind == MethodKind.PropertySet ||
                    method.MethodKind == MethodKind.Constructor ||
                    method.MethodKind == MethodKind.StaticConstructor ||
                    method.MethodKind == MethodKind.EventAdd ||
                    method.MethodKind == MethodKind.EventRemove ||
                    method.MethodKind == MethodKind.Destructor)
                {
                    return;
                }
            }
            
            if (string.IsNullOrEmpty(symbol.Name) || !char.IsUpper(symbol.Name[0]))
            {
                context.ReportDiagnostic(Diagnostic.Create(PascalCaseNaming, symbol.Locations[0], symbol.Name));
            }
        }

        private static void AnalyzeLiterals(SyntaxNodeAnalysisContext context)
        {
            var literal = (LiteralExpressionSyntax)context.Node;
            if (!literal.Token.ValueText.All(char.IsDigit)) return; 
            var value = Convert.ToInt64(literal.Token.Value);
            if (value <= 2 && value >= -1) return;
            var parent = literal.Parent;
            if (parent is ConstantPatternSyntax || parent is CaseSwitchLabelSyntax || parent.Ancestors().OfType<AttributeSyntax>().Any()) return;
            
            if (parent.Parent is VariableDeclaratorSyntax v && 
                v.Parent is VariableDeclarationSyntax vd && 
                vd.Parent is FieldDeclarationSyntax fd)
            {
                if (fd.Modifiers.Any(m => m.IsKind(SyntaxKind.ConstKeyword)))
                    return;
                
                bool hasStatic = fd.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword));
                bool hasReadonly = fd.Modifiers.Any(m => m.IsKind(SyntaxKind.ReadOnlyKeyword));
                if (hasStatic && hasReadonly)
                    return;
            }
            
            context.ReportDiagnostic(Diagnostic.Create(MagicNumberProhibited, literal.GetLocation(), literal.Token.ValueText));
        }

        // FASE 1+2: Nuevos analizadores

        private static void AnalyzeTaskUsage(SyntaxNodeAnalysisContext context)
        {
            var typeInfo = context.SemanticModel.GetTypeInfo(context.Node);
            var typeStr = typeInfo.Type?.ToDisplayString() ?? "";
            
            if (typeStr.StartsWith("System.Threading.Tasks.Task"))
            {
                var isInEngine = context.Node.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.Engine") ?? false;
                if (!isInEngine) return;
                
                // Verificar [EngineSetup]
                var method = context.Node.FirstAncestorOrSelf<MethodDeclarationSyntax>();
                if (method != null)
                {
                    var methodSymbol = context.SemanticModel.GetDeclaredSymbol(method);
                    if (methodSymbol?.GetAttributes().Any(a => a.AttributeClass?.Name == "EngineSetupAttribute") ?? false)
                        return;
                }
                
                context.ReportDiagnostic(Diagnostic.Create(TaskInEngineProhibited, context.Node.GetLocation()));
            }
        }

        private static void AnalyzeDateTimeUsage(SyntaxNodeAnalysisContext context)
        {
            var memberAccess = (MemberAccessExpressionSyntax)context.Node;
            var memberName = memberAccess.ToString();
            
            if (memberName == "DateTime.Now" || 
                memberName == "DateTime.UtcNow" ||
                memberName == "Environment.TickCount" ||
                memberName == "Environment.TickCount64")
            {
                var isInEngine = memberAccess.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.Engine") ?? false;
                if (isInEngine)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DateTimeInEngineProhibited, memberAccess.GetLocation()));
                }
            }
        }

        private static void AnalyzeExceptionControlFlow(SyntaxNodeAnalysisContext context)
        {
            var tryStatement = (TryStatementSyntax)context.Node;
            
            // Verificar try-catch en loop
            bool isInLoop = tryStatement.Ancestors().Any(n => 
                n is ForStatementSyntax || 
                n is ForEachStatementSyntax || 
                n is WhileStatementSyntax ||
                n is DoStatementSyntax);
            
            if (isInLoop)
            {
                foreach (var catchClause in tryStatement.Catches)
                {
                    context.ReportDiagnostic(Diagnostic.Create(ExceptionsAsControlFlow, catchClause.GetLocation()));
                }
            }
        }

        private static void AnalyzeArrayCreationForPool(SyntaxNodeAnalysisContext context)
        {
            var arrayCreation = (ArrayCreationExpressionSyntax)context.Node;
            
            // Verificar si es byte[]
            var typeInfo = context.SemanticModel.GetTypeInfo(arrayCreation);
            if (typeInfo.Type is not IArrayTypeSymbol arrayType || 
                arrayType.ElementType.SpecialType != SpecialType.System_Byte)
                return;
            
            var isInEngine = arrayCreation.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.Engine") ?? false;
            if (!isInEngine) return;
            
            // Verificar [EngineSetup]
            var method = arrayCreation.FirstAncestorOrSelf<MethodDeclarationSyntax>();
            if (method != null)
            {
                var methodSymbol = context.SemanticModel.GetDeclaredSymbol(method);
                if (methodSymbol?.GetAttributes().Any(a => a.AttributeClass?.Name == "EngineSetupAttribute") ?? false)
                    return;
            }
            
            // Verificar tamaño si es literal
            if (arrayCreation.Type.RankSpecifiers.Count > 0)
            {
                var rankSpecifier = arrayCreation.Type.RankSpecifiers[0];
                if (rankSpecifier.Sizes.Count > 0)
                {
                    var sizeExpr = rankSpecifier.Sizes[0];
                    var constValue = context.SemanticModel.GetConstantValue(sizeExpr);
                    if (constValue.HasValue)
                    {
                        var size = Convert.ToInt32(constValue.Value);
                        if (size <= 16) return; // Stackalloc pequeño OK
                    }
                }
            }
            
            context.ReportDiagnostic(Diagnostic.Create(ArrayPoolRequired, arrayCreation.GetLocation()));
        }

        private static void AnalyzeByteArrayParameter(SymbolAnalysisContext context, IMethodSymbol method)
        {
            if (method.DeclaredAccessibility != Accessibility.Public) return;
            
            var nsName = method.ContainingNamespace?.ToDisplayString() ?? "";
            if (!nsName.StartsWith("NetShaper.Engine")) return;
            
            foreach (var param in method.Parameters)
            {
                if (param.Type is IArrayTypeSymbol array &&
                    array.ElementType.SpecialType == SpecialType.System_Byte)
                {
                    context.ReportDiagnostic(Diagnostic.Create(SpanMemoryPreferred, param.Locations[0]));
                }
            }
        }

        private static void AnalyzeArrayPoolBalance(SymbolAnalysisContext context, IMethodSymbol method)
        {
            if (method.DeclaringSyntaxReferences.Length == 0) return;
            var syntax = method.DeclaringSyntaxReferences[0].GetSyntax();
            
            // Contar Rent y Return
            var invocations = syntax.DescendantNodes().OfType<InvocationExpressionSyntax>().ToList();
            
            int rentCount = invocations.Count(inv => 
                inv.ToString().Contains("ArrayPool") && inv.ToString().Contains(".Rent("));
            
            int returnCount = invocations.Count(inv => 
                inv.ToString().Contains("ArrayPool") && inv.ToString().Contains(".Return("));
            
            if (rentCount == 0) return; // No usa ArrayPool
            
            // Verificar excepciones
            bool hasBufferOwner = method.GetAttributes().Any(a => 
                a.AttributeClass?.Name == "BufferOwnerAttribute");
            
            bool returnsArray = method.ReturnType is IArrayTypeSymbol;
            
            if (rentCount != returnCount && !hasBufferOwner && !returnsArray)
            {
                context.ReportDiagnostic(Diagnostic.Create(ArrayPoolOwnership, method.Locations[0]));
            }
        }

        private static void AnalyzeArrayPoolBufferSize(SyntaxNodeAnalysisContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;
            
            // Detectar ArrayPool.Shared.Rent(N)
            var invocationStr = invocation.ToString();
            if (!invocationStr.Contains("ArrayPool") || !invocationStr.Contains(".Rent("))
                return;
            
            if (invocation.ArgumentList.Arguments.Count == 0) return;
            
            var arg = invocation.ArgumentList.Arguments[0];
            var constValue = context.SemanticModel.GetConstantValue(arg.Expression);
            
            if (constValue.HasValue)
            {
                var size = Convert.ToInt32(constValue.Value);
                var validSizes = new[] { 1500, 2048, 4096, 8192, 65536 };
                
                if (!validSizes.Contains(size))
                {
                    context.ReportDiagnostic(Diagnostic.Create(BufferSizeNonStandard, arg.GetLocation()));
                }
            }
        }

        private static void AnalyzeEngineLogging(SyntaxNodeAnalysisContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;
            
            var symbolInfo = context.SemanticModel.GetSymbolInfo(invocation);
            if (symbolInfo.Symbol is not IMethodSymbol method) return;
            
            // Detectar ILogger.Log*
            var containingType = method.ContainingType?.ToDisplayString() ?? "";
            if (!containingType.Contains("ILogger")) return;
            
            var isInEngine = invocation.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString().StartsWith("NetShaper.Engine") ?? false;
            if (!isInEngine) return;
            
            // Verificar si usa string literals o interpolation
            foreach (var arg in invocation.ArgumentList.Arguments)
            {
                if (arg.Expression is LiteralExpressionSyntax literal && literal.Token.ValueText is string ||
                    arg.Expression is InterpolatedStringExpressionSyntax)
                {
                    context.ReportDiagnostic(Diagnostic.Create(StructuredLoggingRequired, arg.GetLocation()));
                }
            }
        }

        private static void AnalyzeCatchExceptionBoundary(SyntaxNodeAnalysisContext context)
        {
            var catchClause = (CatchClauseSyntax)context.Node;
            
            if (catchClause.Declaration?.Type.ToString() != "Exception") return;
            
            // Verificar si está en boundary
            var method = catchClause.FirstAncestorOrSelf<MethodDeclarationSyntax>();
            if (method == null) return;
            
            var methodSymbol = context.SemanticModel.GetDeclaredSymbol(method);
            if (methodSymbol == null) return;
            
            // Verificar atributo [Boundary]
            bool isBoundary = methodSymbol.GetAttributes().Any(a => a.AttributeClass?.Name == "BoundaryAttribute");
            bool isMain = method.Identifier.Text == "Main";
            
            // Verificar si es controller (simplificado)
            bool isController = methodSymbol.ContainingType?.BaseType?.Name.Contains("Controller") ?? false;
            
            bool isProgram = method.FirstAncestorOrSelf<CompilationUnitSyntax>()?.SyntaxTree.FilePath.EndsWith("Program.cs") ?? false;
            
            if (!isBoundary && !isMain && !isController && !isProgram)
            {
                context.ReportDiagnostic(Diagnostic.Create(CatchExceptionOnlyBoundaries, catchClause.GetLocation()));
            }
        }

        private static void AnalyzeDisposableVariable(SyntaxNodeAnalysisContext context)
        {
            var variable = (VariableDeclaratorSyntax)context.Node;
            
            if (variable.Parent?.Parent is not VariableDeclarationSyntax declaration) return;
            
            var typeInfo = context.SemanticModel.GetTypeInfo(declaration.Type);
            if (typeInfo.Type == null) return;
            
            // Verificar si implementa IDisposable
            bool isDisposable = typeInfo.Type.AllInterfaces.Any(i => i.Name == "IDisposable") ||
                               typeInfo.Type.Name == "IDisposable";
            
            if (!isDisposable) return;
            
            // Verificar si está en using statement
            bool isInUsing = variable.Ancestors().OfType<UsingStatementSyntax>().Any();
            
            // Verificar using declaration (C# 8+)
            bool isUsingDeclaration = declaration.Parent is LocalDeclarationStatementSyntax localDecl &&
                                     !localDecl.UsingKeyword.IsKind(SyntaxKind.None);
            
            if (isInUsing || isUsingDeclaration) return;
            
            // Verificar si hay .Dispose() llamado en el método  
            var method = variable.FirstAncestorOrSelf<MethodDeclarationSyntax>();
            if (method != null)
            {
                var variableName = variable.Identifier.Text;
                bool hasDispose = method.DescendantNodes()
                    .OfType<InvocationExpressionSyntax>()
                    .Any(inv => inv.ToString().Contains(variableName) && inv.ToString().Contains("Dispose"));
                
                if (hasDispose) return;
            }
            
            context.ReportDiagnostic(Diagnostic.Create(DisposableWithoutUsing, variable.GetLocation()));
        }

        // FASES 3-5: Métodos adicionales

        private static void AnalyzeNestingDepth(SymbolAnalysisContext context, IMethodSymbol method)
        {
            if (method.DeclaringSyntaxReferences.Length == 0) return;
            var syntax = method.DeclaringSyntaxReferences[0].GetSyntax();
            int maxNesting = CalculateMaxNesting(syntax);
            var nsName = method.ContainingNamespace?.ToDisplayString() ?? "";
            int limit = 3;
            if (nsName.StartsWith("NetShaper.Engine"))
            {
                limit = 2;
                if (method.GetAttributes().Any(a => a.AttributeClass?.Name == "BatchProcessorAttribute")) limit = 4;
            }
            if (maxNesting > limit)
                context.ReportDiagnostic(Diagnostic.Create(NestingDepthExceeded, method.Locations[0], method.Name, maxNesting, limit));
        }

        private static int CalculateMaxNesting(SyntaxNode node, int currentDepth = 0)
        {
            int maxDepth = currentDepth;
            foreach (var child in node.ChildNodes())
            {
                int childDepth = currentDepth;
                if (child is IfStatementSyntax || child is ForStatementSyntax || child is ForEachStatementSyntax ||
                    child is WhileStatementSyntax || child is DoStatementSyntax || child is SwitchStatementSyntax || child is TryStatementSyntax)
                    childDepth++;
                maxDepth = Math.Max(maxDepth, CalculateMaxNesting(child, childDepth));
            }
            return maxDepth;
        }

        private static void AnalyzeSafeHandleRequired(SymbolAnalysisContext context, IMethodSymbol method)
        {
            var hasPInvoke = method.GetAttributes().Any(a => a.AttributeClass?.Name == "DllImportAttribute" || a.AttributeClass?.Name == "LibraryImportAttribute");
            if (hasPInvoke && method.ReturnType.SpecialType == SpecialType.System_IntPtr)
                context.ReportDiagnostic(Diagnostic.Create(SafeHandleRequired, method.Locations[0]));
        }

        private static void AnalyzeFixedStatement(SyntaxNodeAnalysisContext context)
        {
            var fixedStatement = (FixedStatementSyntax)context.Node;
            var nsName = fixedStatement.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString() ?? "";
            if (!nsName.StartsWith("NetShaper.Engine") && !nsName.StartsWith("NetShaper.Native"))
                context.ReportDiagnostic(Diagnostic.Create(FixedOnlyInEngineNative, fixedStatement.GetLocation()));
        }

        private static void AnalyzeHardcodedSecrets(SyntaxNodeAnalysisContext context)
        {
            var literal = (LiteralExpressionSyntax)context.Node;
            if (literal.Token.Value is not string text || text.Length < 8) return;
            var lowerText = text.ToLower();
            if ((lowerText.Contains("password") || lowerText.Contains("secret") || lowerText.Contains("apikey") || 
                lowerText.Contains("api_key") || lowerText.Contains("token")) && text.Length > 20 && !text.Contains(" "))
                context.ReportDiagnostic(Diagnostic.Create(HardcodedSecretDetected, literal.GetLocation()));
            else if (text.Length > 32 && !text.Contains(" ") && CalculateShannonEntropy(text) > 4.5)
                context.ReportDiagnostic(Diagnostic.Create(HardcodedSecretDetected, literal.GetLocation()));
        }

        private static double CalculateShannonEntropy(string text)
        {
            var freq = text.GroupBy(c => c).ToDictionary(g => g.Key, g => g.Count() / (double)text.Length);
            return -freq.Values.Sum(p => p * Math.Log(p, 2));
        }

        private static void AnalyzeInputValidation(SymbolAnalysisContext context, IMethodSymbol method)
        {
            if (method.DeclaredAccessibility != Accessibility.Public || method.DeclaringSyntaxReferences.Length == 0) return;
            if (method.DeclaringSyntaxReferences[0].GetSyntax() is not MethodDeclarationSyntax syntax) return;
            foreach (var param in method.Parameters)
            {
                if (param.Type.IsValueType || param.NullableAnnotation == NullableAnnotation.Annotated) continue;
                var hasValidation = syntax.Body?.Statements.OfType<ExpressionStatementSyntax>()
                    .Any(stmt => stmt.ToString().Contains($"ThrowIfNull({param.Name}")) ?? false;
                if (!hasValidation)
                    context.ReportDiagnostic(Diagnostic.Create(MissingInputValidation, param.Locations[0]));
            }
        }

        private static void AnalyzeNullableParameter(SymbolAnalysisContext context, IMethodSymbol method)
        {
            if (method.DeclaredAccessibility != Accessibility.Public) return;
            foreach (var param in method.Parameters)
                if (!param.Type.IsValueType && param.NullableAnnotation == NullableAnnotation.Annotated)
                    context.ReportDiagnostic(Diagnostic.Create(NullableParameterInPublicApi, param.Locations[0]));
        }

        private static void AnalyzeRedundantThis(SyntaxNodeAnalysisContext context)
        {
            var memberAccess = (MemberAccessExpressionSyntax)context.Node;
            if (memberAccess.Expression is not ThisExpressionSyntax) return;
            var enclosingMethod = memberAccess.FirstAncestorOrSelf<MethodDeclarationSyntax>();
            if (enclosingMethod != null)
            {
                var hasShadowing = enclosingMethod.ParameterList?.Parameters.Any(p => p.Identifier.Text == memberAccess.Name.Identifier.Text) ?? false;
                if (!hasShadowing)
                    context.ReportDiagnostic(Diagnostic.Create(RedundantThis, memberAccess.Expression.GetLocation()));
            }
        }

        private static void AnalyzeVarUsage(SyntaxNodeAnalysisContext context)
        {
            var variableDeclaration = (VariableDeclarationSyntax)context.Node;
            if (variableDeclaration.Type.IsVar) return;
            var declarator = variableDeclaration.Variables.FirstOrDefault();
            if (declarator?.Initializer?.Value is ObjectCreationExpressionSyntax or CastExpressionSyntax)
                context.ReportDiagnostic(Diagnostic.Create(VarPreferred, variableDeclaration.Type.GetLocation()));
        }

        private static void AnalyzeDomainAttribute(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            var nsName = type.ContainingNamespace?.ToDisplayString() ?? "";
            if (!nsName.Contains("Domain") && !nsName.Contains("Abstractions")) return;
            if (type.TypeKind != TypeKind.Class && type.TypeKind != TypeKind.Struct) return;
            var domainAttributes = new[] { "EntityAttribute", "ValueObjectAttribute", "AggregateRootAttribute", "DomainEventAttribute", "UseCaseAttribute" };
            var hasDomainAttribute = type.GetAttributes().Any(a => domainAttributes.Contains(a.AttributeClass?.Name ?? ""));
            if (!hasDomainAttribute && type.DeclaredAccessibility == Accessibility.Public && 
                !type.GetAttributes().Any(a => a.AttributeClass?.Name == "InfrastructureAttribute"))
                context.ReportDiagnostic(Diagnostic.Create(MissingDomainAttribute, type.Locations[0]));
        }

        private static void AnalyzeThrowInTechnicalDomain(SyntaxNodeAnalysisContext context)
        {
            var throwStatement = (ThrowStatementSyntax)context.Node;
            var nsName = throwStatement.FirstAncestorOrSelf<BaseNamespaceDeclarationSyntax>()?.Name.ToString() ?? "";
            if (!nsName.StartsWith("NetShaper.Engine") && !nsName.StartsWith("NetShaper.Native")) return;
            
            // Verificar si está en un constructor (tienen su propia sintaxis)
            var constructor = throwStatement.FirstAncestorOrSelf<ConstructorDeclarationSyntax>();
            if (constructor != null) return;  // Constructores están permitidos
            
            var method = throwStatement.FirstAncestorOrSelf<MethodDeclarationSyntax>();
            if (method != null)
            {
                var methodSymbol = context.SemanticModel.GetDeclaredSymbol(method);
                if (methodSymbol != null)
                {
                    // Excluir métodos marcados como setup o boundaries
                    if (methodSymbol.GetAttributes().Any(a => a.AttributeClass?.Name == "EngineSetupAttribute" || a.AttributeClass?.Name == "BoundaryAttribute"))
                        return;
                }
            }
            context.ReportDiagnostic(Diagnostic.Create(ThrowInTechnicalDomain, throwStatement.GetLocation()));
        }

        private static void AnalyzeStructuredLoggingRecommended(SyntaxNodeAnalysisContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;
            var symbolInfo = context.SemanticModel.GetSymbolInfo(invocation);
            if (symbolInfo.Symbol is not IMethodSymbol method || !(method.ContainingType?.ToDisplayString().Contains("ILogger") ?? false)) return;
            foreach (var arg in invocation.ArgumentList.Arguments)
                if (arg.Expression is LiteralExpressionSyntax literal && literal.Token.ValueText is string str && !str.Contains("{") && str.Length > 5)
                    context.ReportDiagnostic(Diagnostic.Create(StructuredLoggingRecommended, arg.GetLocation()));
        }

        // Reglas adicionales

        private static void AnalyzeMemberOrder(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            var members = type.GetMembers().Where(m => !m.IsImplicitlyDeclared).OrderBy(m => m.Locations[0].SourceSpan.Start).ToList();
            if (members.Count < 2) return;
            
            int lastOrder = -1;
            foreach (var member in members)
            {
                int currentOrder = GetMemberOrderPriority(member);
                if (currentOrder < lastOrder)
                {
                    context.ReportDiagnostic(Diagnostic.Create(MemberOrderViolation, member.Locations[0], member.Name));
                }
                lastOrder = currentOrder;  // FIX: Era Math.Max(lastOrder, currentOrder) - causaba FP
            }
        }

        private static int GetMemberOrderPriority(ISymbol member)
        {
            return member switch
            {
                IFieldSymbol f when f.IsConst => 0,
                IFieldSymbol f when f.IsStatic => 1,
                IFieldSymbol => 2,
                IMethodSymbol m when m.MethodKind == MethodKind.StaticConstructor => 3,
                IMethodSymbol m when m.MethodKind == MethodKind.Constructor => 4,
                IPropertySymbol p when p.IsStatic => 5,
                IPropertySymbol => 6,
                IMethodSymbol m when m.IsStatic => 7,
                IMethodSymbol => 8,
                _ => 99
            };
        }

        private static void AnalyzeDIViaConstructor(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            if (type.TypeKind != TypeKind.Class) return;
            var nsName = type.ContainingNamespace?.ToDisplayString() ?? "";
            if (nsName.StartsWith("NetShaper.Engine") || nsName.StartsWith("NetShaper.UI")) return;
            
            // Buscar campos que parezcan dependencias (interfaces, servicios)
            var dependencyFields = type.GetMembers().OfType<IFieldSymbol>()
                .Where(f => !f.IsStatic && !f.IsConst && 
                           (f.Type.TypeKind == TypeKind.Interface || 
                            f.Type.Name.EndsWith("Service") || 
                            f.Type.Name.EndsWith("Repository") ||
                            f.Type.Name.EndsWith("Factory")))
                .ToList();
            
            if (dependencyFields.Count == 0) return;
            
            // Verificar si hay constructores que NO inyectan estas dependencias
            var constructors = type.GetMembers().OfType<IMethodSymbol>()
                .Where(m => m.MethodKind == MethodKind.Constructor && !m.IsStatic).ToList();
            
            bool anyConstructorInjectsDeps = constructors.Any(ctor => ctor.Parameters.Length >= dependencyFields.Count / 2);
            
            if (!anyConstructorInjectsDeps && dependencyFields.Count > 2)
            {
                context.ReportDiagnostic(Diagnostic.Create(DINotViaConstructor, type.Locations[0], type.Name));
            }
        }

        private static void AnalyzeInvariantTests(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            var nsName = type.ContainingNamespace?.ToDisplayString() ?? "";
            if (!nsName.Contains("Domain")) return;
            
            // Solo aplicar a tipos con invariantes
            var hasInvariant = type.GetMembers().Any(m => 
                m.Name.Contains("Invariant") || 
                m.Name.Contains("Validate") || 
                m.GetAttributes().Any(a => a.AttributeClass?.Name == "InvariantAttribute"));
            
            if (!hasInvariant) return;
            
            // Verificar si existe clase de test (heurística: nombre del tipo + "Tests")
            // Nota: Esto es limitado ya que no podemos acceder fácilmente a los tests desde el analyzer
            // Solo reportamos como WARNING
            var hasTestAttribute = type.GetAttributes().Any(a => a.AttributeClass?.Name == "TestedAttribute");
            
            if (!hasTestAttribute)
            {
                context.ReportDiagnostic(Diagnostic.Create(MissingInvariantTests, type.Locations[0], type.Name));
            }
        }

        private static void AnalyzeTransactionalEvents(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            var nsName = type.ContainingNamespace?.ToDisplayString() ?? "";
            if (!nsName.StartsWith("NetShaper.Engine")) return;
            
            // Buscar eventos con nombres que sugieran transacciones
            var events = type.GetMembers().OfType<IEventSymbol>().ToList();
            foreach (var evt in events)
            {
                if (evt.Name.Contains("Transaction") || 
                    evt.Name.Contains("Commit") || 
                    evt.Name.Contains("Rollback") ||
                    evt.Type.Name.Contains("Transaction"))
                {
                    context.ReportDiagnostic(Diagnostic.Create(TransactionalEventsInEngine, evt.Locations[0]));
                }
            }
        }

        // Final batch

        private static void AnalyzeAbstractionsDependencies(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            var nsName = type.ContainingNamespace?.ToDisplayString() ?? "";
            if (!nsName.StartsWith("NetShaper.Abstractions")) return;
            
            // Buscar usos de tipos de otros namespaces NetShaper (excepto System.*)
            var members = type.GetMembers();
            foreach (var member in members)
            {
                ITypeSymbol typeToCheck = member switch
                {
                    IFieldSymbol field => field.Type,
                    IPropertySymbol prop => prop.Type,
                    IMethodSymbol method => method.ReturnType,
                    _ => null
                };
                
                if (typeToCheck != null)
                {
                    var typeName = typeToCheck.ToDisplayString();
                    if (typeName.StartsWith("NetShaper.") && 
                        !typeName.StartsWith("NetShaper.Abstractions") &&
                        !typeName.StartsWith("System."))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(AbstractionsWithDependencies, member.Locations[0]));
                    }
                }
            }
        }

        private static void AnalyzeLowCohesion(SymbolAnalysisContext context, INamedTypeSymbol type)
        {
            if (type.TypeKind != TypeKind.Class) return;
            
            // Excluir Engine/UI (infraestructura compleja legítima)
            var nsName = type.ContainingNamespace?.ToDisplayString() ?? "";
            if (nsName.StartsWith("NetShaper.Engine") || nsName.StartsWith("NetShaper.UI"))
                return;
            
            var fields = type.GetMembers().OfType<IFieldSymbol>().Where(f => !f.IsStatic && !f.IsConst).ToList();
            var methods = type.GetMembers().OfType<IMethodSymbol>()
                .Where(m => m.MethodKind == MethodKind.Ordinary && !m.IsStatic).ToList();
            
            if (fields.Count < 3 || methods.Count < 3) return;
            
            // Heurística simple: contar cuántos métodos NO usan ningún campo
            int methodsNotUsingFields = 0;
            foreach (var method in methods)
            {
                if (method.DeclaringSyntaxReferences.Length == 0) continue;
                var syntax = method.DeclaringSyntaxReferences[0].GetSyntax();
                
                bool usesAnyField = fields.Any(f => syntax.ToString().Contains(f.Name));
                if (!usesAnyField)
                    methodsNotUsingFields++;
            }
            
            // Si >50% de métodos no usan campos, posible baja cohesión
            if (methodsNotUsingFields > methods.Count / 2)
            {
                context.ReportDiagnostic(Diagnostic.Create(LowCohesion, type.Locations[0], type.Name));
            }
        }

        private static void AnalyzeGCCollectPattern(SyntaxNodeAnalysisContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;
            
            // Ya detectado por R1101, pero agregar checks adicionales
            var invocationStr = invocation.ToString();
            if (!invocationStr.Contains("GC.Collect")) return;
            
            // Buscar si hay WaitForPendingFinalizers después
            var method = invocation.FirstAncestorOrSelf<MethodDeclarationSyntax>();
            if (method != null)
            {
                var invocationLine = invocation.GetLocation().GetLineSpan().StartLinePosition.Line;
                var statements = method.Body?.Statements ?? method.ExpressionBody?.DescendantNodes().OfType<StatementSyntax>() ?? Enumerable.Empty<StatementSyntax>();
                
                bool hasWaitAfter = statements.Any(s => 
                    s.GetLocation().GetLineSpan().StartLinePosition.Line > invocationLine &&
                    s.ToString().Contains("WaitForPendingFinalizers"));
                
                if (!hasWaitAfter)
                {
                    context.ReportDiagnostic(Diagnostic.Create(GCCollectWithSuppression, invocation.GetLocation()));
                }
            }
        }
        
        #endregion
    }
}

]]>
</file>
<file path="NetShaper.StressTest\PerformanceTests.cs">
<![CDATA[
// NetShaper.StressTest/PerformanceTests.cs
using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Abstractions;

namespace NetShaper.StressTest
{
    /// <summary>
    /// Unified performance tests for NetShaper Engine with configurable threads.
    /// </summary>
    internal static class PerformanceTests
    {
        private const int PerformancePort = 55555;
        private const int PacketCount = 200_000;
        private const int WarmupMs = 500;
        private const int TestDuration = 2000;

        public static async Task RunPerformanceTestAsync(int threadCount)
        {
            Console.WriteLine($">>> NetShaper Performance Test ({threadCount} thread{(threadCount > 1 ? "s" : "")}) <<<");
            Console.Write("Calentando... ");

            using var engine = TestServiceFactory.CreateEngine(threadCount);

            var result = engine.Start($"outbound and udp.DstPort == {PerformancePort}");
            if (result != StartResult.Success)
            {
                Console.WriteLine($"❌ Error: {result}");
                return;
            }

            Console.WriteLine("OK");
            await Task.Delay(WarmupMs);

            // Telemetry baseline
            long packetsBefore = engine.PacketCount;
            long gen0Before = GC.CollectionCount(0);

            // Traffic generation
            Console.WriteLine($"Enviando {PacketCount:N0} paquetes mixtos...");
            
            var sw = Stopwatch.StartNew();
            await GenerateTrafficAsync(PacketCount, PerformancePort);
            sw.Stop();

            // Wait for processing
            await Task.Delay(TestDuration);
            engine.Stop();

            // Calculate results
            long packetsProcessed = engine.PacketCount - packetsBefore;
            long gen0After = GC.CollectionCount(0);
            int gen0Collections = (int)(gen0After - gen0Before);

            double pps = packetsProcessed / (sw.ElapsedMilliseconds / 1000.0);
            
            // Expected PPS calculation
            int expectedSingleThread = 83_000;
            double expectedPPS = threadCount == 1 ? expectedSingleThread : expectedSingleThread * 0.98; // slight degradation with more threads
            double efficiency = (pps / expectedPPS) * 100.0;

            // Display results
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine($"RESULTS ({threadCount} thread{(threadCount > 1 ? "s" : "")}):");
            Console.WriteLine($"PPS: {pps:N0}");
            Console.WriteLine($"Expected PPS: {expectedPPS:N0}");
            Console.WriteLine($"Efficiency: {efficiency:F1}%");
            Console.WriteLine($"GC Gen0: {gen0Collections}");
            Console.WriteLine($"Packets Processed: {packetsProcessed:N0}");
            Console.WriteLine("────────────────────────────────────────");

            // Verdicts
            if (gen0Collections == 0)
                Console.WriteLine("✅ ZERO ALLOC CONFIRMED");
            else
                Console.WriteLine($"⚠️  {gen0Collections} Gen0 collections detected");

            if (efficiency >= 90)
                Console.WriteLine("✅ EXCELLENT PERFORMANCE (≥90%)");
            else if (efficiency >= 70)
                Console.WriteLine("✅ GOOD PERFORMANCE (≥70%)");
            else if (efficiency >= 50)
                Console.WriteLine("⚠️ MODERATE PERFORMANCE (50-70%)");
            else
                Console.WriteLine("❌ POOR PERFORMANCE (<50%)");

            Console.WriteLine("════════════════════════════════════════");
        }

        private static async Task GenerateTrafficAsync(int count, int port)
        {
            await Task.Run(() =>
            {
                using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                var endpoint = new IPEndPoint(IPAddress.Loopback, port);
                
                byte[] small = new byte[64];
                byte[] medium = new byte[512];
                byte[] large = new byte[1400];

                for (int i = 0; i < count; i++)
                {
                    byte[] payload = (i % 3) switch
                    {
                        0 => small,
                        1 => medium,
                        _ => large
                    };
                    
                    socket.SendTo(payload, endpoint);
                    
                    if ((i & 255) == 0)
                        Thread.Yield();
                }
            });
        }
    }
}

]]>
</file>
<file path="NetShaper.StressTest\Program.cs">
<![CDATA[
using System;
using System.Threading.Tasks;

namespace NetShaper.StressTest
{
    internal static class Program
    {
        private static async Task<int> Main(string[] args)
        {
            Console.OutputEncoding = System.Text.Encoding.UTF8;
            Console.Title = "NetShaper Performance Tests";

            // Command line usage: dotnet run [threads|stability]
            // Example: dotnet run 4
            // Example: dotnet run stability
            if (args.Length > 0)
            {
                if (args[0].ToLowerInvariant() == "stability")
                {
                    RealTests.RunStabilityReal();
                    return 0;
                }
                else if (int.TryParse(args[0], out int threads) && threads >= 1 && threads <= 16)
                {
                    await PerformanceTests.RunPerformanceTestAsync(threads);
                    return 0;
                }
                else
                {
                    Console.WriteLine($"Invalid argument: {args[0]}");
                    Console.WriteLine("Usage: dotnet run [threads|stability]");
                    Console.WriteLine("  dotnet run 4           - Run with 4 threads");
                    Console.WriteLine("  dotnet run stability   - Run stability test (10000 cycles)");
                    return 1;
                }
            }

            // Interactive mode
            while (true)
            {
                Console.Clear();
                Console.WriteLine("════════════════════════════════════════");
                Console.WriteLine("   NetShaper Performance Test Suite");
                Console.WriteLine("════════════════════════════════════════");
                Console.WriteLine();
                Console.WriteLine("Selecciona un test:");
                Console.WriteLine();
                Console.WriteLine("1-16  = Performance Test (N threads)");
                Console.WriteLine("        1 = Single thread (83k PPS)");
                Console.WriteLine("        4 = Quad thread (~81k PPS)");
                Console.WriteLine();
                Console.WriteLine("S     = Stability Test (10,000 Start/Stop cycles)");
                Console.WriteLine();
                Console.WriteLine("0     = Salir");
                Console.Write("\nOpción: ");

                var input = Console.ReadLine()?.Trim();
                
                if (input == "0")
                    return 0;

                if (input?.ToUpperInvariant() == "S")
                {
                    Console.WriteLine();
                    RealTests.RunStabilityReal();
                    Console.WriteLine();
                    Console.WriteLine("Presiona cualquier tecla para continuar...");
                    Console.ReadKey(true);
                }
                else if (int.TryParse(input, out int threadCount) && threadCount >= 1 && threadCount <= 16)
                {
                    Console.WriteLine();
                    await PerformanceTests.RunPerformanceTestAsync(threadCount);
                    
                    Console.WriteLine();
                    Console.WriteLine("Presiona cualquier tecla para continuar...");
                    Console.ReadKey(true);
                }
                else
                {
                    Console.WriteLine("Número inválido. Debe ser entre 1 y 16.");
                    Console.ReadKey(true);
                }
            }
        }
    }
}

]]>
</file>
<file path="NetShaper.StressTest\RealTests.cs">
<![CDATA[
// NetShaper.StressTest/RealTests.cs
using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Engine;
using NetShaper.Abstractions;

namespace NetShaper.StressTest
{
    static class RealTests
    {
        private const int PerformancePort = 55555;
        private const int WarmupPackets = 200;
        private const int MeasurementPackets = 200_000;
        private const int BurstSize = 5000;
        private const int BurstCount = 10;

        public static void RunStabilityReal()
        {
            Console.WriteLine(">>> INICIANDO TEST DE ESTABILIDAD REAL (uso correcto) <<<");
            int cycles = 10000;
            int totalFallos = 0;
            int startFailures = 0;
            int captureLoopFailures = 0;
            int exceptionFailures = 0;
            var failedCycles = new List<int>();
            
            var sw = Stopwatch.StartNew();
            for (int i = 1; i <= cycles; i++)
            {
                FailureType failure = RunSingleCycle(i);
                
                if (failure != FailureType.None)
                {
                    totalFallos++;
                    failedCycles.Add(i);
                    
                    switch (failure)
                    {
                        case FailureType.StartFailed:
                            startFailures++;
                            break;
                        case FailureType.CaptureLoopFailed:
                            captureLoopFailures++;
                            break;
                        case FailureType.Exception:
                            exceptionFailures++;
                            break;
                    }
                }
                
                if (i % 100 == 0) Console.Write(".");
            }

            sw.Stop();
            Console.WriteLine("\n");
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine("RESUMEN ESTABILIDAD REAL:");
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine($"Tiempo total: {sw.ElapsedMilliseconds} ms");
            Console.WriteLine($"Ciclos ejecutados: {cycles:N0}");
            Console.WriteLine($"Fallos totales: {totalFallos}");
            
            if (totalFallos > 0)
            {
                Console.WriteLine("\nFALLOS POR CATEGORÍA:");
                Console.WriteLine($"  - Start failures:       {startFailures}");
                Console.WriteLine($"  - CaptureLoop failures: {captureLoopFailures}");
                Console.WriteLine($"  - Exceptions:           {exceptionFailures}");
                
                Console.WriteLine($"\nTasa de fallo: {(totalFallos * 100.0 / cycles):F3}%");
                Console.WriteLine($"\nCiclos con fallos: {string.Join(", ", failedCycles.Take(20))}");
                if (failedCycles.Count > 20)
                    Console.WriteLine($"  ... y {failedCycles.Count - 20} más");
            }
            
            Console.WriteLine("═══════════════════════════════════════════════════════");
            Console.WriteLine(totalFallos == 0 ? "✅ ESTABLE" : "❌ INESTABLE");
            Console.WriteLine("═══════════════════════════════════════════════════════");
        }
        
        private enum FailureType
        {
            None,
            StartFailed,
            CaptureLoopFailed,
            Exception
        }

        private static FailureType RunSingleCycle(int ciclo)
        {
            try
            {
                using var engine = TestServiceFactory.CreateEngine();
                using var cts = new CancellationTokenSource();

                StartResult startResult = engine.Start("ip", cts.Token);
                if (startResult != StartResult.Success)
                {
                    Console.WriteLine($"\n[FAIL ciclo {ciclo}] Start failed: {startResult}");
                    return FailureType.StartFailed;
                }

                var captureResult = EngineResult.InvalidState;
                var t = new Thread(() =>
                {
                    captureResult = engine.RunCaptureLoop();
                })
                {
                    IsBackground = true
                };

                t.Start();

                Thread.Sleep(Random.Shared.Next(0, 5));
                engine.Stop();

                // Espera activa por estado, no por timeout fijo
                SpinWait spin = default;
                while (engine.IsRunning)
                    spin.SpinOnce();

                t.Join(); // ya debería estar fuera

                // Validate capture loop result
                if (captureResult != EngineResult.Success && captureResult != EngineResult.Stopped)
                {
                    Console.WriteLine($"\n[FAIL ciclo {ciclo}] CaptureLoop error: {captureResult}");
                    return FailureType.CaptureLoopFailed;
                }

                return FailureType.None;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\n[EXCEPTION ciclo {ciclo}] {ex.GetType().Name}: {ex.Message}");
                Console.WriteLine($"  Stack: {ex.StackTrace?.Split('\n').FirstOrDefault()?.Trim()}");
                return FailureType.Exception;
            }
        }

        private static async Task WarmupAsync()
        {
            Console.Write("Calentando... ");
            await Task.Run(() => SendTrafficMixed(WarmupPackets, PerformancePort));
            Thread.Sleep(200);
            Console.WriteLine("OK");
        }

        private static void PrepareGcForMeasurement()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
        }

        private static async Task RunMeasurementTrafficAsync()
        {
            Console.WriteLine($"Enviando {MeasurementPackets:N0} paquetes mixtos...");
            await Task.Run(() => SendTrafficMixed(MeasurementPackets, PerformancePort));
        }

        private static void RunBursts()
        {
            Console.WriteLine("Enviando ráfagas (bursts)...");
            for (int i = 0; i < BurstCount; i++)
            {
                SendTrafficBurst(BurstSize, PerformancePort);
                Thread.Sleep(10);
            }
        }

        private static void PrintPerformanceSummary(long packetCount, long memStart, long memEnd, int g0Start, int g0End, long tStart, long tEnd)
        {
            long memDelta = memEnd - memStart;
            int gcTriggers = g0End - g0Start;
            double seconds = Stopwatch.GetElapsedTime(tStart, tEnd).TotalSeconds - 0.5;
            if (seconds < 0.1) seconds = 0.1;
            long pps = (long)(packetCount / seconds);

            Console.WriteLine("────────────────────────────────");
            Console.WriteLine("RESULTADOS NIVEL 3:");
            Console.WriteLine($"PPS: {pps:N0}");
            Console.WriteLine($"GC Gen0: {gcTriggers}");
            Console.WriteLine($"Memoria Delta: {memDelta / 1024.0:F2} KB");
            Console.WriteLine($"Paquetes procesados: {packetCount:N0}");

            if (gcTriggers == 0) Console.WriteLine("✅ ZERO ALLOC CONFIRMADO (Nivel 3)");
            else Console.WriteLine("❌ Asignaciones detectadas");
        }

        private static void SendTrafficMixed(int count, int port)
        {
            using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket.Connect(IPAddress.Loopback, port);

            byte[] small = new byte[64];
            byte[] medium = new byte[512];
            byte[] large = new byte[1400];
            for (int i = 0; i < count; i++)
            {
                int pick = i % 3;
                if (pick == 0) socket.Send(small);
                else if (pick == 1) socket.Send(medium);
                else socket.Send(large);

                if ((i & 1023) == 0) Thread.Yield();
            }
        }

        private static void SendTrafficBurst(int count, int port)
        {
            using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket.Connect(IPAddress.Loopback, port);
            byte[] data = new byte[1400];
            for (int i = 0; i < count; i++) socket.Send(data);
        }
    }
}
]]>
</file>
<file path="NetShaper.StressTest\TestServiceFactory.cs">
<![CDATA[
// NetShaper.StressTest/TestServiceFactory.cs
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;

namespace NetShaper.StressTest
{
    /// <summary>
    /// Factory for creating test services using dependency injection.
    /// Provides a centralized way to create properly configured instances for testing.
    /// </summary>
    internal static class TestServiceFactory
    {
        /// <summary>
        /// Creates a new IEngine instance with all required dependencies.
        /// </summary>
        /// <returns>A configured engine instance.</returns>
        public static IEngine CreateEngine()
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            return provider.GetRequiredService<IEngine>();
        }

        /// <summary>
        /// Creates a new IPacketCapture instance.
        /// </summary>
        /// <returns>A configured packet capture adapter.</returns>
        public static IPacketCapture CreatePacketCapture()
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            return provider.GetRequiredService<IPacketCapture>();
        }

        /// <summary>
        /// Creates a new IPacketLogger instance.
        /// </summary>
        /// <returns>A configured packet logger.</returns>
        public static IPacketLogger CreatePacketLogger()
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            return provider.GetRequiredService<IPacketLogger>();
        }

        /// <summary>
        /// Creates a new IEngine instance with custom logger and capture adapter.
        /// </summary>
        /// <param name="logger">The packet logger to use.</param>
        /// <param name="capture">The packet capture adapter to use.</param>
        /// <returns>A configured engine instance.</returns>
        public static IEngine CreateEngine(IPacketLogger logger, IPacketCapture capture)
        {
            // For custom instances, create Engine with single thread
            Func<IPacketCapture> captureFactory = () => capture;
            return new Engine.Engine(logger, captureFactory, threadCount: 1);
        }

        /// <summary>
        /// Creates a new Engine instance with N threads using batch mode.
        /// </summary>
        public static Engine.Engine CreateEngine(int threadCount = 4)
        {
            var services = new ServiceCollection();
            services.AddNetShaperServices();
            var provider = services.BuildServiceProvider();
            
            var logger = provider.GetRequiredService<IPacketLogger>();
            
            // Factory uses interface instead of concrete type
            Func<IPacketCapture> captureFactory = () => 
                new NetShaper.Native.WinDivertAdapter();
            
            return new Engine.Engine(logger, captureFactory, threadCount);
        }
    }
}

]]>
</file>
<file path="NetShaper.UI\Bootstrap.cs">
<![CDATA[
// NetShaper.UI/Bootstrap.cs
using Microsoft.Extensions.DependencyInjection;
using NetShaper.Abstractions;
using NetShaper.Composition;
using NetShaper.UI.Controllers;
using NetShaper.UI.Views;

namespace NetShaper.UI
{
    /// <summary>
    /// Composition root for the NetShaper UI application.
    /// Configures dependency injection and builds the service provider.
    /// </summary>
    static class Bootstrap
    {
        /// <summary>
        /// Builds and configures the application controller with all dependencies.
        /// </summary>
        /// <returns>Configured application controller instance.</returns>
        public static IApplicationController BuildController()
        {
            var services = new ServiceCollection();
            
            // Register core NetShaper services (logger, capture, engine)
            services.AddNetShaperServices();
            
            // Register UI-specific services
            services.AddSingleton<IConsoleView, ConsoleStatsView>();
            services.AddSingleton<IApplicationController, ConsoleApplicationController>();
            
            var serviceProvider = services.BuildServiceProvider();
            
            // Resolve the application controller from the container
            return serviceProvider.GetRequiredService<IApplicationController>();
        }
    }
}
]]>
</file>
<file path="NetShaper.UI\Program.cs">
<![CDATA[
// NetShaper.App/Program.cs
using System;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.UI;

namespace NetShaper.UI
{
    sealed class Program
    {
        static async Task<int> Main(string[] args)
        {
            using CancellationTokenSource cts = new CancellationTokenSource();

            Console.CancelKeyPress += (_, e) =>
            {
                e.Cancel = true;
                cts.Cancel();
            };

            try
            {
                var controller = Bootstrap.BuildController();
                return await controller.RunAsync(cts.Token);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CRITICAL] {ex.GetType().Name}: {ex.Message}");
                return 1;
            }
        }
    }
}

]]>
</file>
<file path="NetShaper.UI\Controllers\ConsoleApplicationController.cs">
<![CDATA[
using System;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Abstractions;
using NetShaper.UI.Views;

namespace NetShaper.UI.Controllers
{
    sealed class ConsoleApplicationController : IApplicationController
    {
        private readonly EngineController _controller;

        public ConsoleApplicationController(IEngine engine, IPacketLogger logger, IConsoleView consoleView)
        {
            ArgumentNullException.ThrowIfNull(engine);
            ArgumentNullException.ThrowIfNull(logger);
            ArgumentNullException.ThrowIfNull(consoleView);

            _controller = new EngineController(engine, logger, consoleView);
        }

        public async Task<int> RunAsync(CancellationToken ct)
        {
            while (!ct.IsCancellationRequested)
            {
                if (_controller.IsRunning)
                {
                    // RUNNING STATE: Show stats, wait for ESC
                    await RunningStateAsync(ct);
                }
                else
                {
                    // MENU STATE: Show menu, process commands
                    var exitCode = await MenuStateAsync(ct);
                    if (exitCode.HasValue)
                        return exitCode.Value;
                }
            }

            return 0;
        }

        private async Task<int?> MenuStateAsync(CancellationToken ct)
        {
            DrawMenu();
            
            var key = Console.ReadKey(true).KeyChar;

            switch (key)
            {
                case '1':
                    HandleStart(ct);
                    return null; // Continue to running state
                    
                case '3':
                    return await HandleExitAsync(ct);
                    
                default:
                    return null; // Ignore invalid input, redraw menu
            }
        }

        private async Task RunningStateAsync(CancellationToken ct)
        {
            Console.Clear();
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine("   NetShaper - Capturando Paquetes");
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine();
            Console.WriteLine("Presiona ESC para detener y volver al menú");
            Console.WriteLine();
            Console.WriteLine("Estadísticas:");
            Console.WriteLine();

            // Wait for ESC while engine is running
            while (_controller.IsRunning && !ct.IsCancellationRequested)
            {
                if (Console.KeyAvailable)
                {
                    var key = Console.ReadKey(true).Key;
                    if (key == ConsoleKey.Escape)
                    {
                        HandleStop();
                        await Task.Delay(300); // Wait for clean shutdown
                        break;
                    }
                }
                
                await Task.Delay(50);
            }
        }

        private void HandleStart(CancellationToken ct)
        {
            StartResult result = _controller.Start("ip and (tcp or udp)", ct);
            
            if (result != StartResult.Success)
            {
                Console.Clear();
                Console.WriteLine("════════════════════════════════════════");
                Console.WriteLine("   Error al Iniciar");
                Console.WriteLine("════════════════════════════════════════");
                Console.WriteLine();
                Console.WriteLine($"❌ Error: {result}");
                Console.WriteLine();
                
                if (result == StartResult.OpenFailed)
                {
                    Console.WriteLine("Posibles causas:");
                    Console.WriteLine("- NO tienes privilegios de ADMINISTRADOR");
                    Console.WriteLine("- El driver WinDivert no está instalado");
                }
                else if (result == StartResult.InvalidFilter)
                {
                    Console.WriteLine("El filtro WinDivert es inválido");
                }
                
                Console.WriteLine();
                Console.WriteLine("Presiona cualquier tecla para volver al menú...");
                Console.ReadKey(true);
            }
            // If success, RunAsync will transition to RunningState automatically
        }

        private void HandleStop()
        {
            _controller.Stop();
        }

        private async Task<int> HandleExitAsync(CancellationToken ct)
        {
            await _controller.ShutdownAsync();
            return 0;
        }

        private static void DrawMenu()
        {
            Console.Clear();
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine("   NetShaper - Packet Shaping Monitor");
            Console.WriteLine("════════════════════════════════════════");
            Console.WriteLine();
            Console.WriteLine("⚠️  IMPORTANTE: Debe ejecutarse como ADMINISTRADOR");
            Console.WriteLine();
            Console.WriteLine("1. Start  - Iniciar captura de paquetes");
            Console.WriteLine("3. Exit   - Salir del programa");
            Console.WriteLine();
            Console.WriteLine("Filtro: ip and (tcp or udp)");
            Console.WriteLine();
        }
    }
}

]]>
</file>
<file path="NetShaper.UI\Controllers\EngineController.cs">
<![CDATA[
// NetShaper.UI/Controllers/EngineController.cs
using System;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using NetShaper.Abstractions;
using NetShaper.UI.Views;

namespace NetShaper.UI.Controllers
{
    public sealed class EngineController : IDisposable
    {
        private readonly IEngine _engine;
        private readonly IPacketLogger _logger;
        private readonly IConsoleView _consoleView;

        private CancellationTokenSource? _linkedCts;
        private Task? _captureTask;
        private Task? _monitorTask;
        private int _running;

        private const int ConsoleUpdateInterval = 1000; // Milisegundos entre actualizaciones

        public EngineController(IEngine engine, IPacketLogger logger, IConsoleView consoleView)
        {
            ArgumentNullException.ThrowIfNull(engine);
            ArgumentNullException.ThrowIfNull(logger);
            ArgumentNullException.ThrowIfNull(consoleView);
            
            _engine = engine;
            _logger = logger;
            _consoleView = consoleView;
            _running = 0;
        }

        public bool IsRunning => _engine.IsRunning;
        public long PacketCount => _engine.PacketCount;

        public StartResult Start(string filter, CancellationToken appToken)
        {
            if (Interlocked.CompareExchange(ref _running, 1, 0) != 0)
                return StartResult.AlreadyRunning;

            // Dispose old CTS if exists (protection against multiple Start calls)
            var oldCts = Interlocked.Exchange(ref _linkedCts, null);
            oldCts?.Dispose();

            _linkedCts = CancellationTokenSource.CreateLinkedTokenSource(appToken);

            StartResult result = _engine.Start(filter, _linkedCts.Token);
            if (result != StartResult.Success)
            {
                // Cleanup: dispose CTS in error path to prevent memory leak
                _linkedCts?.Dispose();
                _linkedCts = null;
                CleanupRunningFlag();
                return result;
            }

            _captureTask = Task.Run(() =>
            {
                try
                {
                    _engine.RunCaptureLoop();
                }
                finally
                {
                    _linkedCts?.Cancel(); // fuerza salida del monitor
                    CleanupRunningFlag();
                }
            }, _linkedCts.Token);

            _monitorTask = StartMonitorTask(_linkedCts.Token);
            return StartResult.Success;
        }

        public void Stop()
        {
            if (Interlocked.CompareExchange(ref _running, 0, 1) != 1)
                return;

            _engine.Stop();
            _linkedCts?.Cancel();
        }

        public async Task ShutdownAsync()
        {
            Stop();

            try
            {
                if (_captureTask != null)
                    await _captureTask.ConfigureAwait(false);

                if (_monitorTask != null)
                    await _monitorTask.ConfigureAwait(false);
            }
            finally
            {
                _linkedCts?.Dispose();
                (_engine as IDisposable)?.Dispose();
            }
        }

        private Task StartMonitorTask(CancellationToken ct)
    {
        return Task.Run(async () =>
        {
            long last = _engine.PacketCount;

            while (!ct.IsCancellationRequested)
            {
                try
                {
                    await Task.Delay(1000, ct).ConfigureAwait(false);

                    long current = _engine.PacketCount;
                    long delta = current - last;

                    _logger.Log(new PacketLogEntry(
                        Stopwatch.GetTimestamp(),
                        LogLevel.Info,
                        LogCode.PacketProcessed,
                        delta));

                    // Only update console if not cancelled
                    if (!ct.IsCancellationRequested)
                    {
                        _consoleView.UpdateStats(delta, current);
                    }

                    last = current;
                }
                catch (TaskCanceledException)
                {
                    // Expected when stopping
                    break;
                }
            }
        }, ct);
    }

        private void CleanupRunningFlag()
        {
            Interlocked.Exchange(ref _running, 0);
        }

        public void Dispose()
        {
            _linkedCts?.Dispose();
        }
    }
}

]]>
</file>
<file path="NetShaper.UI\Views\ConsoleStatsView.cs">
<![CDATA[
// NetShaper.UI/Views/ConsoleStatsView.cs
using System;

namespace NetShaper.UI.Views
{
    /// <summary>
    /// Console implementation of statistics view.
    /// Handles direct console manipulation (cursor positioning, formatting).
    /// </summary>
    public sealed class ConsoleStatsView : IConsoleView
    {
        private readonly int _displayLine;
        private long _lastTotal = 0;

        public ConsoleStatsView()
        {
            _displayLine = Console.CursorTop;
            Console.WriteLine(); // Reserve line for stats
        }

        public void UpdateStats(long packetsPerSecond, long totalPackets)
        {
            Console.SetCursorPosition(0, _displayLine);
            
            // Visual indicator if capturing
            string status = totalPackets > _lastTotal ? "🟢" : (totalPackets > 0 ? "⏸️" : "⚪");
            
            Console.Write(
                $"{status} PPS: {packetsPerSecond,10:N0} | Total paquetes: {totalPackets,12:N0}   ");
            
            _lastTotal = totalPackets;
        }
    }
}

]]>
</file>
<file path="NetShaper.UI\Views\IConsoleView.cs">
<![CDATA[
// NetShaper.UI/Views/IConsoleView.cs
namespace NetShaper.UI.Views
{
    /// <summary>
    /// Interface for console UI rendering.
    /// Separates presentation logic from business logic (SRP).
    /// </summary>
    public interface IConsoleView
    {
        /// <summary>
        /// Updates the statistics display in the console.
        /// </summary>
        /// <param name="packetsPerSecond">Current packets processed per second.</param>
        /// <param name="totalPackets">Total packets processed.</param>
        void UpdateStats(long packetsPerSecond, long totalPackets);
    }
}

]]>
</file>
</codebase>